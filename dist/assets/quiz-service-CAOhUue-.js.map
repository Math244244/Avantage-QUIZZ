{"version":3,"mappings":"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","names":["MONTH_NAMES","MONTH_NAMES_LOWERCASE","getCurrentMonthIndex","getCurrentMonthNumber","getCurrentYear","normalizeMonthFormat","month","year","monthName","monthLower","monthIndex","m","parts","monthPart","monthIdx","yearPart","createMonthlyProgressId","userId","normalizedMonth","extractYearFromMonth","COLLECTIONS","saveQuizResult","quizData","user","auth","score","clientId","getCurrentClientId","resultData","Timestamp","resultRef","safeFirestoreWrite","addDoc","collection","db","updateUserStats","__vitePreload","n","updateMonthlyProgress","invalidateCache","buildCacheKey","error","getUserQuizResults","uid","limitCount","cacheKey","cached","getCachedValue","q","query","where","orderBy","limit","querySnapshot","safeFirestoreRead","getDocs","results","doc","setCachedValue","progressId","progressRef","progressData","setDoc","getAnnualProgress","progress","data","dataYear"],"ignoreList":[],"sources":["../../js/month-utils.js","../../js/services/quiz-service.js"],"sourcesContent":["/**\n * Utilitaires pour la gestion des mois (Section 2 - Logique M√©tier)\n * \n * Ce module fournit des fonctions pour normaliser et g√©rer les formats de mois\n * afin d'√©viter les incoh√©rences entre dashboard et quiz.\n */\n\n/**\n * Noms des mois en fran√ßais (premi√®re lettre majuscule)\n */\nexport const MONTH_NAMES = [\n    'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',\n    'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'\n];\n\n/**\n * Noms des mois en minuscules (pour compatibilit√©)\n */\nexport const MONTH_NAMES_LOWERCASE = [\n    'janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin',\n    'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'\n];\n\n/**\n * Obtient l'index du mois actuel (0-11)\n * @returns {number} Index du mois actuel (0 = Janvier, 11 = D√©cembre)\n */\nexport function getCurrentMonthIndex() {\n    const now = new Date();\n    return now.getMonth(); // 0-11\n}\n\n/**\n * Obtient le num√©ro du mois actuel (1-12)\n * @returns {number} Num√©ro du mois actuel (1 = Janvier, 12 = D√©cembre)\n */\nexport function getCurrentMonthNumber() {\n    return getCurrentMonthIndex() + 1;\n}\n\n/**\n * Obtient l'ann√©e actuelle\n * @returns {number} Ann√©e actuelle\n */\nexport function getCurrentYear() {\n    return new Date().getFullYear();\n}\n\n/**\n * Normalise le format d'un mois pour garantir la coh√©rence\n * \n * Format de sortie garanti : \"Novembre 2025\" (premi√®re lettre majuscule, espace, ann√©e)\n * \n * @param {string|number} month - Mois (texte ou num√©ro 1-12)\n * @param {number} year - Ann√©e (optionnel, utilise l'ann√©e actuelle par d√©faut)\n * @returns {string} Mois normalis√© au format \"Novembre 2025\"\n */\nexport function normalizeMonthFormat(month, year = getCurrentYear()) {\n    let monthName;\n    \n    // Si c'est un num√©ro (1-12)\n    if (typeof month === 'number') {\n        if (month < 1 || month > 12) {\n            throw new Error(`Num√©ro de mois invalide: ${month}. Doit √™tre entre 1 et 12.`);\n        }\n        monthName = MONTH_NAMES[month - 1];\n    }\n    // Si c'est une cha√Æne\n    else if (typeof month === 'string') {\n        // Normaliser la casse\n        const monthLower = month.toLowerCase().trim();\n        \n        // Chercher dans la liste des mois en minuscules\n        const monthIndex = MONTH_NAMES_LOWERCASE.findIndex(m => m === monthLower);\n        if (monthIndex !== -1) {\n            monthName = MONTH_NAMES[monthIndex];\n        } else {\n            // Essayer de parser un format comme \"novembre 2025\" ou \"Novembre 2025\"\n            const parts = month.split(' ');\n            if (parts.length >= 1) {\n                const monthPart = parts[0].toLowerCase();\n                const monthIdx = MONTH_NAMES_LOWERCASE.findIndex(m => m === monthPart);\n                if (monthIdx !== -1) {\n                    monthName = MONTH_NAMES[monthIdx];\n                    // Si l'ann√©e est dans la cha√Æne, l'utiliser\n                    if (parts.length >= 2) {\n                        const yearPart = parseInt(parts[1]);\n                        if (!isNaN(yearPart)) {\n                            year = yearPart;\n                        }\n                    }\n                } else {\n                    throw new Error(`Format de mois invalide: ${month}`);\n                }\n            } else {\n                throw new Error(`Format de mois invalide: ${month}`);\n            }\n        }\n    } else {\n        throw new Error(`Type de mois invalide: ${typeof month}`);\n    }\n    \n    return `${monthName} ${year}`;\n}\n\n/**\n * Cr√©e un ID de document Firestore pour monthlyProgress\n * Remplace les espaces par des underscores pour √©viter les probl√®mes\n * \n * @param {string} userId - ID de l'utilisateur\n * @param {string|number} month - Mois (texte ou num√©ro)\n * @param {number} year - Ann√©e (optionnel)\n * @returns {string} ID du document au format \"userId_Novembre_2025\"\n */\nexport function createMonthlyProgressId(userId, month, year = getCurrentYear()) {\n    const normalizedMonth = normalizeMonthFormat(month, year);\n    // Remplacer les espaces par des underscores pour l'ID Firestore\n    return `${userId}_${normalizedMonth.replace(/\\s+/g, '_')}`;\n}\n\n/**\n * Extrait l'ann√©e d'une cha√Æne de mois normalis√©e\n * \n * @param {string} normalizedMonth - Mois normalis√© au format \"Novembre 2025\"\n * @returns {number} Ann√©e extraite\n */\nexport function extractYearFromMonth(normalizedMonth) {\n    const parts = normalizedMonth.split(' ');\n    if (parts.length >= 2) {\n        const year = parseInt(parts[parts.length - 1]);\n        if (!isNaN(year)) {\n            return year;\n        }\n    }\n    return getCurrentYear();\n}\n\n/**\n * Valide qu'un format de mois est correct\n * \n * @param {string} month - Mois √† valider\n * @returns {boolean} True si le format est valide\n */\nexport function isValidMonthFormat(month) {\n    try {\n        normalizeMonthFormat(month);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\nexport default {\n    MONTH_NAMES,\n    MONTH_NAMES_LOWERCASE,\n    getCurrentMonthIndex,\n    getCurrentMonthNumber,\n    getCurrentYear,\n    normalizeMonthFormat,\n    createMonthlyProgressId,\n    extractYearFromMonth,\n    isValidMonthFormat\n};\n\n\n","/**\n * Service de Gestion des Quiz et R√©sultats\n * \n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions quiz\n */\n\nimport { db, auth } from '../firebase-config.js';\nimport { \n    collection, \n    doc, \n    getDocs, \n    addDoc,\n    setDoc,\n    query,\n    where,\n    orderBy,\n    limit,\n    startAfter,\n    Timestamp\n} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\nimport { safeFirestoreRead, safeFirestoreWrite } from '../rate-limiter.js';\nimport { getCurrentClientId } from '../client-manager.js';\nimport { normalizeMonthFormat, createMonthlyProgressId, extractYearFromMonth } from '../month-utils.js';\nimport { buildCacheKey, getCachedValue, setCachedValue, invalidateCache } from './cache-service.js';\n\nconst COLLECTIONS = {\n    quizResults: 'quizResults',\n    monthlyProgress: 'monthlyProgress'\n};\n\n/**\n * Sauvegarder un r√©sultat de quiz\n */\nexport async function saveQuizResult(quizData) {\n    try {\n        const user = auth.currentUser;\n        if (!user) throw new Error('Utilisateur non connect√©');\n        \n        const score = quizData.score;\n        if (isNaN(score) || score < 0 || score > 100) {\n            throw new Error(`Score invalide: ${score}. Doit √™tre entre 0 et 100.`);\n        }\n        \n        if (!quizData.totalQuestions || quizData.totalQuestions <= 0) {\n            throw new Error(`Nombre total de questions invalide: ${quizData.totalQuestions}`);\n        }\n        if (quizData.correctAnswers < 0 || quizData.correctAnswers > quizData.totalQuestions) {\n            throw new Error(`Nombre de bonnes r√©ponses invalide: ${quizData.correctAnswers}`);\n        }\n        \n        const normalizedMonth = normalizeMonthFormat(quizData.month || new Date().getMonth() + 1, quizData.year || new Date().getFullYear());\n        const year = extractYearFromMonth(normalizedMonth);\n        \n        const clientId = await getCurrentClientId();\n        \n        const resultData = {\n            userId: user.uid,\n            userEmail: user.email,\n            moduleId: quizData.moduleId,\n            moduleName: quizData.moduleName,\n            score: score,\n            correctAnswers: quizData.correctAnswers,\n            totalQuestions: quizData.totalQuestions,\n            timeElapsed: quizData.timeElapsed,\n            answers: quizData.answers,\n            date: Timestamp.now(),\n            completedAt: Timestamp.now(),\n            month: normalizedMonth,\n            year: year,\n            clientId: clientId\n        };\n        \n        const resultRef = await safeFirestoreWrite(() => \n            addDoc(collection(db, COLLECTIONS.quizResults), resultData)\n        );\n        console.log('‚úÖ R√©sultat de quiz sauvegard√©:', resultRef.id);\n        \n        // Import dynamique pour √©viter d√©pendance circulaire\n        const { updateUserStats } = await import('./user-service.js');\n        await updateUserStats(user.uid, quizData.score);\n        await updateMonthlyProgress(user.uid, quizData.month, quizData.score);\n\n        invalidateCache(buildCacheKey(['quizResults', user.uid]));\n        invalidateCache(buildCacheKey(['monthlyResults', user.uid]));\n        invalidateCache(buildCacheKey(['annualProgress', user.uid]));\n        invalidateCache('users');\n        invalidateCache('users-stats');\n        \n        return resultRef.id;\n    } catch (error) {\n        console.error('‚ùå Erreur sauvegarde r√©sultat:', error);\n        throw error;\n    }\n}\n\n/**\n * R√©cup√©rer tous les r√©sultats d'un utilisateur (sans pagination - pour compatibilit√©)\n */\nexport async function getUserQuizResults(uid, limitCount = 50) {\n    const cacheKey = buildCacheKey(['quizResults', uid, limitCount]);\n    const cached = getCachedValue(cacheKey);\n    if (cached) {\n        return cached;\n    }\n\n    try {\n        const clientId = await getCurrentClientId();\n        \n        const q = query(\n            collection(db, COLLECTIONS.quizResults),\n            where('userId', '==', uid),\n            where('clientId', '==', clientId),\n            orderBy('date', 'desc'),\n            limit(limitCount)\n        );\n        \n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\n        const results = [];\n        \n        querySnapshot.forEach((doc) => {\n            results.push({ id: doc.id, ...doc.data() });\n        });\n        \n        console.log(`üìä ${results.length} r√©sultats charg√©s`);\n        setCachedValue(cacheKey, results, 'quizResults');\n        return results;\n    } catch (error) {\n        console.error('‚ùå Erreur r√©cup√©ration r√©sultats:', error);\n        throw error;\n    }\n}\n\n/**\n * ‚úÖ CORRECTION SECTION 7 : Pagination - R√©cup√©rer les r√©sultats d'un utilisateur avec pagination\n * @param {string} uid - ID de l'utilisateur\n * @param {number} pageSize - Nombre d'√©l√©ments par page (d√©faut: 20)\n * @param {QueryDocumentSnapshot|null} lastDoc - Document de d√©part pour la pagination\n * @returns {Promise<{results: Array, lastDoc: QueryDocumentSnapshot|null, hasMore: boolean}>}\n */\nexport async function getUserQuizResultsPaginated(uid, pageSize = 20, lastDoc = null) {\n    try {\n        const clientId = await getCurrentClientId();\n        \n        const constraints = [\n            where('userId', '==', uid),\n            where('clientId', '==', clientId),\n            orderBy('date', 'desc'),\n            limit(pageSize + 1) // +1 pour d√©tecter s'il y a plus de r√©sultats\n        ];\n        \n        let q = query(collection(db, COLLECTIONS.quizResults), ...constraints);\n        \n        // Si on a un document de d√©part, commencer apr√®s\n        if (lastDoc) {\n            q = query(q, startAfter(lastDoc));\n        }\n        \n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\n        const results = [];\n        let newLastDoc = null;\n        let hasMore = false;\n        \n        querySnapshot.forEach((doc, index) => {\n            if (index < pageSize) {\n                results.push({ id: doc.id, ...doc.data() });\n            } else {\n                hasMore = true;\n            }\n        });\n        \n        if (querySnapshot.docs.length > 0 && results.length === pageSize) {\n            newLastDoc = querySnapshot.docs[pageSize - 1];\n        }\n        \n        console.log(`üìä ${results.length} r√©sultats charg√©s (pagination)`);\n        return {\n            results,\n            lastDoc: newLastDoc,\n            hasMore\n        };\n    } catch (error) {\n        console.error('‚ùå Erreur r√©cup√©ration r√©sultats pagin√©s:', error);\n        throw error;\n    }\n}\n\n/**\n * R√©cup√©rer les r√©sultats d'un mois sp√©cifique\n */\nexport async function getMonthlyResults(uid, month) {\n    const cacheKey = buildCacheKey(['monthlyResults', uid, month]);\n    const cached = getCachedValue(cacheKey);\n    if (cached) {\n        return cached;\n    }\n\n    try {\n        const clientId = await getCurrentClientId();\n        \n        const q = query(\n            collection(db, COLLECTIONS.quizResults),\n            where('userId', '==', uid),\n            where('month', '==', month),\n            where('clientId', '==', clientId),\n            orderBy('date', 'desc')\n        );\n        \n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\n        const results = [];\n        \n        querySnapshot.forEach((doc) => {\n            results.push({ id: doc.id, ...doc.data() });\n        });\n        \n        setCachedValue(cacheKey, results, 'monthlyProgress');\n        return results;\n    } catch (error) {\n        console.error('‚ùå Erreur r√©cup√©ration r√©sultats mensuels:', error);\n        throw error;\n    }\n}\n\n/**\n * Mettre √† jour la progression mensuelle\n */\nexport async function updateMonthlyProgress(uid, month, score) {\n    try {\n        const normalizedMonth = normalizeMonthFormat(month);\n        const year = extractYearFromMonth(normalizedMonth);\n        \n        const progressId = createMonthlyProgressId(uid, normalizedMonth);\n        const progressRef = doc(db, COLLECTIONS.monthlyProgress, progressId);\n        \n        const clientId = await getCurrentClientId();\n        \n        const progressData = {\n            userId: uid,\n            month: normalizedMonth,\n            year: year,\n            score: score,\n            completed: true,\n            completedAt: Timestamp.now(),\n            updatedAt: Timestamp.now(),\n            clientId: clientId\n        };\n        \n        await safeFirestoreWrite(() => setDoc(progressRef, progressData, { merge: true }));\n        console.log('‚úÖ Progression mensuelle mise √† jour');\n\n        invalidateCache(buildCacheKey(['monthlyResults', uid]));\n        invalidateCache(buildCacheKey(['annualProgress', uid, year]));\n    } catch (error) {\n        console.error('‚ùå Erreur mise √† jour progression:', error);\n        throw error;\n    }\n}\n\n/**\n * R√©cup√©rer la progression annuelle\n */\nexport async function getAnnualProgress(uid, year = new Date().getFullYear()) {\n    const cacheKey = buildCacheKey(['annualProgress', uid, year]);\n    const cached = getCachedValue(cacheKey);\n    if (cached) {\n        return cached;\n    }\n\n    try {\n        const clientId = await getCurrentClientId();\n        \n        const q = query(\n            collection(db, COLLECTIONS.monthlyProgress),\n            where('userId', '==', uid),\n            where('clientId', '==', clientId)\n        );\n        \n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\n        const progress = {};\n        \n        querySnapshot.forEach((doc) => {\n            const data = doc.data();\n            const dataYear = data.year || extractYearFromMonth(data.month);\n            if (dataYear === year) {\n                const normalizedMonth = normalizeMonthFormat(data.month, dataYear);\n                progress[normalizedMonth] = {\n                    ...data,\n                    month: normalizedMonth,\n                    year: dataYear\n                };\n            }\n        });\n        \n        console.log('üìÖ Progression annuelle charg√©e');\n        setCachedValue(cacheKey, progress, 'annualProgress');\n        return progress;\n    } catch (error) {\n        console.error('‚ùå Erreur r√©cup√©ration progression:', error);\n        throw error;\n    }\n}\n\n"],"file":"quiz-service-CAOhUue-.js"}