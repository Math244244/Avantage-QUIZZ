{"version":3,"file":"question-service-DWEDRzPv.js","sources":["../../js/services/question-service.js"],"sourcesContent":["/**\r\n * Service de Gestion des Questions\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions questions\r\n */\r\n\r\nimport { db, auth } from '../firebase-config.js';\r\nimport { \r\n    collection, \r\n    doc, \r\n    getDoc, \r\n    getDocs, \r\n    addDoc,\r\n    updateDoc,\r\n    deleteDoc,\r\n    query,\r\n    where,\r\n    orderBy,\r\n    limit,\r\n    startAfter,\r\n    Timestamp\r\n} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\r\nimport { safeFirestoreRead, safeFirestoreWrite } from '../rate-limiter.js';\r\nimport { buildCacheKey, getCachedValue, setCachedValue, invalidateCache } from './cache-service.js';\r\nimport { createAuditLog, createImportLog } from './audit-service.js';\r\n\r\nconst COLLECTIONS = {\r\n    questions: 'questions'\r\n};\r\n\r\n/**\r\n * ADMIN: R√©cup√©rer toutes les questions avec filtres optionnels (sans pagination - pour compatibilit√©)\r\n */\r\nexport async function getQuestions(filters = {}) {\r\n    const cacheKey = buildCacheKey(['questions', JSON.stringify(filters || {})]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        let q = collection(db, COLLECTIONS.questions);\r\n        const constraints = [];\r\n        \r\n        if (filters.module) {\r\n            constraints.push(where('module', '==', filters.module));\r\n        }\r\n        if (filters.month) {\r\n            constraints.push(where('month', '==', filters.month));\r\n        }\r\n        if (filters.year) {\r\n            constraints.push(where('year', '==', filters.year));\r\n        }\r\n        \r\n        constraints.push(orderBy('createdAt', 'desc'));\r\n        \r\n        if (constraints.length > 0) {\r\n            q = query(q, ...constraints);\r\n        }\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const questions = [];\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            questions.push({ id: doc.id, ...doc.data() });\r\n        });\r\n        \r\n        console.log(`üìö ${questions.length} questions charg√©es`);\r\n        setCachedValue(cacheKey, questions, 'questions');\r\n        return questions;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration questions:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 7 : Pagination - R√©cup√©rer les questions avec pagination\r\n * @param {Object} filters - Filtres optionnels\r\n * @param {number} pageSize - Nombre d'√©l√©ments par page (d√©faut: 20)\r\n * @param {QueryDocumentSnapshot|null} lastDoc - Document de d√©part pour la pagination\r\n * @returns {Promise<{questions: Array, lastDoc: QueryDocumentSnapshot|null, hasMore: boolean}>}\r\n */\r\nexport async function getQuestionsPaginated(filters = {}, pageSize = 20, lastDoc = null) {\r\n    try {\r\n        let q = collection(db, COLLECTIONS.questions);\r\n        const constraints = [];\r\n        \r\n        if (filters.module) {\r\n            constraints.push(where('module', '==', filters.module));\r\n        }\r\n        if (filters.month) {\r\n            constraints.push(where('month', '==', filters.month));\r\n        }\r\n        if (filters.year) {\r\n            constraints.push(where('year', '==', filters.year));\r\n        }\r\n        \r\n        constraints.push(orderBy('createdAt', 'desc'));\r\n        constraints.push(limit(pageSize + 1)); // +1 pour d√©tecter s'il y a plus de r√©sultats\r\n        \r\n        if (constraints.length > 0) {\r\n            q = query(q, ...constraints);\r\n        }\r\n        \r\n        // Si on a un document de d√©part, commencer apr√®s\r\n        if (lastDoc) {\r\n            q = query(q, startAfter(lastDoc));\r\n        }\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const questions = [];\r\n        let newLastDoc = null;\r\n        let hasMore = false;\r\n        \r\n        querySnapshot.forEach((doc, index) => {\r\n            if (index < pageSize) {\r\n                questions.push({ id: doc.id, ...doc.data() });\r\n            } else {\r\n                hasMore = true;\r\n            }\r\n        });\r\n        \r\n        if (querySnapshot.docs.length > 0 && questions.length === pageSize) {\r\n            newLastDoc = querySnapshot.docs[pageSize - 1];\r\n        }\r\n        \r\n        console.log(`üìö ${questions.length} questions charg√©es (pagination)`);\r\n        return {\r\n            questions,\r\n            lastDoc: newLastDoc,\r\n            hasMore\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration questions pagin√©es:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Cr√©er une nouvelle question\r\n */\r\nexport async function createQuestion(questionData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        if (!questionData.question || questionData.question.length < 10) {\r\n            throw new Error('La question doit contenir au moins 10 caract√®res');\r\n        }\r\n        if (!questionData.options || questionData.options.length !== 4) {\r\n            throw new Error('La question doit avoir exactement 4 options');\r\n        }\r\n        if (questionData.correctAnswer === undefined || questionData.correctAnswer < 0 || questionData.correctAnswer > 3) {\r\n            throw new Error('La r√©ponse correcte doit √™tre entre 0 et 3');\r\n        }\r\n        if (!questionData.explanation || questionData.explanation.length < 20) {\r\n            throw new Error('L\\'explication doit contenir au moins 20 caract√®res');\r\n        }\r\n        if (!['auto', 'loisir', 'vr', 'tracteur'].includes(questionData.module)) {\r\n            throw new Error('Module invalide');\r\n        }\r\n        if (!questionData.month || questionData.month < 1 || questionData.month > 12) {\r\n            throw new Error('Mois invalide');\r\n        }\r\n        \r\n        const newQuestion = {\r\n            question: questionData.question.trim(),\r\n            options: questionData.options.map(opt => opt.trim()),\r\n            correctAnswer: parseInt(questionData.correctAnswer),\r\n            explanation: questionData.explanation.trim(),\r\n            module: questionData.module,\r\n            month: parseInt(questionData.month),\r\n            year: questionData.year || new Date().getFullYear(),\r\n            createdAt: Timestamp.now(),\r\n            createdBy: user.uid,\r\n            updatedAt: Timestamp.now()\r\n        };\r\n        \r\n        const questionRef = await safeFirestoreWrite(() => \r\n            addDoc(collection(db, COLLECTIONS.questions), newQuestion)\r\n        );\r\n        console.log('‚úÖ Question cr√©√©e:', questionRef.id);\r\n        \r\n        await createAuditLog({\r\n            action: 'CREATE_QUESTION',\r\n            questionId: questionRef.id,\r\n            adminId: user.uid,\r\n            adminEmail: user.email\r\n        });\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return questionRef.id;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur cr√©ation question:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Mettre √† jour une question existante\r\n */\r\nexport async function updateQuestion(questionId, questionData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        const questionRef = doc(db, COLLECTIONS.questions, questionId);\r\n        \r\n        const updatedData = {\r\n            ...questionData,\r\n            updatedAt: Timestamp.now()\r\n        };\r\n        \r\n        delete updatedData.createdAt;\r\n        delete updatedData.createdBy;\r\n        \r\n        await safeFirestoreWrite(() => updateDoc(questionRef, updatedData));\r\n        console.log('‚úÖ Question mise √† jour:', questionId);\r\n        \r\n        await createAuditLog({\r\n            action: 'UPDATE_QUESTION',\r\n            questionId: questionId,\r\n            adminId: user.uid,\r\n            adminEmail: user.email,\r\n            changes: questionData\r\n        });\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur mise √† jour question:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Supprimer une question\r\n */\r\nexport async function deleteQuestion(questionId) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        const questionRef = doc(db, COLLECTIONS.questions, questionId);\r\n        \r\n        const questionDoc = await safeFirestoreRead(() => getDoc(questionRef));\r\n        const questionData = questionDoc.data();\r\n        \r\n        await safeFirestoreWrite(() => deleteDoc(questionRef));\r\n        console.log('üóëÔ∏è Question supprim√©e:', questionId);\r\n        \r\n        await createAuditLog({\r\n            action: 'DELETE_QUESTION',\r\n            questionId: questionId,\r\n            adminId: user.uid,\r\n            adminEmail: user.email,\r\n            deletedData: questionData\r\n        });\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur suppression question:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Importer des questions depuis JSON\r\n */\r\nexport async function importQuestionsFromJSON(jsonData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        if (!jsonData.module || !jsonData.month || !jsonData.year || !jsonData.questions) {\r\n            throw new Error('Format JSON invalide - champs obligatoires manquants');\r\n        }\r\n        \r\n        if (!Array.isArray(jsonData.questions) || jsonData.questions.length === 0) {\r\n            throw new Error('Le fichier JSON doit contenir au moins une question');\r\n        }\r\n        \r\n        const importedIds = [];\r\n        const errors = [];\r\n        \r\n        for (let i = 0; i < jsonData.questions.length; i++) {\r\n            const question = jsonData.questions[i];\r\n            \r\n            try {\r\n                const questionData = {\r\n                    question: question.question,\r\n                    options: question.options,\r\n                    correctAnswer: question.correctAnswer,\r\n                    explanation: question.explanation,\r\n                    module: jsonData.module,\r\n                    month: jsonData.month,\r\n                    year: jsonData.year\r\n                };\r\n                \r\n                const questionId = await createQuestion(questionData);\r\n                importedIds.push(questionId);\r\n            } catch (err) {\r\n                errors.push({ index: i, error: err.message });\r\n                console.error(`‚ùå Erreur question ${i + 1}:`, err.message);\r\n            }\r\n        }\r\n        \r\n        await createImportLog({\r\n            importedBy: user.uid,\r\n            module: jsonData.module,\r\n            month: jsonData.month,\r\n            year: jsonData.year,\r\n            totalQuestions: jsonData.questions.length,\r\n            successCount: importedIds.length,\r\n            errorCount: errors.length,\r\n            status: errors.length === 0 ? 'success' : 'partial'\r\n        });\r\n        \r\n        console.log(`‚úÖ Import termin√©: ${importedIds.length}/${jsonData.questions.length} questions import√©es`);\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return {\r\n            success: importedIds.length,\r\n            total: jsonData.questions.length,\r\n            errors: errors,\r\n            ids: importedIds\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur import JSON:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: R√©cup√©rer les statistiques des questions\r\n */\r\nexport async function getQuestionsStats() {\r\n    const cacheKey = 'questions-stats';\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const questions = await getQuestions();\r\n        \r\n        const stats = {\r\n            total: questions.length,\r\n            byModule: {},\r\n            byMonth: {},\r\n            byYear: {}\r\n        };\r\n        \r\n        questions.forEach(q => {\r\n            stats.byModule[q.module] = (stats.byModule[q.module] || 0) + 1;\r\n            stats.byMonth[q.month] = (stats.byMonth[q.month] || 0) + 1;\r\n            stats.byYear[q.year] = (stats.byYear[q.year] || 0) + 1;\r\n        });\r\n        \r\n        setCachedValue(cacheKey, stats, 'stats');\r\n        return stats;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur statistiques questions:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n"],"names":["COLLECTIONS","getQuestions","filters","cacheKey","buildCacheKey","cached","getCachedValue","q","collection","db","constraints","where","orderBy","query","querySnapshot","safeFirestoreRead","getDocs","questions","doc","setCachedValue","error","createQuestion","questionData","user","auth","newQuestion","opt","Timestamp","questionRef","safeFirestoreWrite","addDoc","createAuditLog","invalidateCache","deleteQuestion","questionId","getDoc","deleteDoc","importQuestionsFromJSON","jsonData","importedIds","errors","i","question","err","createImportLog","getQuestionsStats","stats"],"mappings":"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"}