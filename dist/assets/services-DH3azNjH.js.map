{"version":3,"mappings":"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","names":["DEFAULT_CLIENT_ID","currentUserClientId","clientIdCacheExpiry","CLIENT_ID_CACHE_TTL","getCurrentClientId","user","currentUser","auth","now","userRef","doc","db","userDoc","safeFirestoreRead","getDoc","clientId","determineClientIdFromEmail","error","email","domain","cacheStore","CACHE_CONFIG","getTTLForDataType","dataType","buildCacheKey","parts","getCachedValue","key","entry","setCachedValue","value","ttlMsOrType","ttlMs","invalidateCache","prefix","_","invalidateByDataType","createImportLog","logData","log","Timestamp","safeFirestoreWrite","addDoc","collection","createAuditLog","COLLECTIONS","createOrUpdateUser","userData","setDoc","getUserProfile","uid","updateUserStats","newScore","runTransaction","transaction","totalQuizzes","newAverage","roundedAverage","updateStreak","getUserQuizResults","__vitePreload","quizService","results","currentStreak","monthsSet","result","months","i","longestStreak","updateDoc","getLeaderboard","limitCount","q","query","where","orderBy","limit","querySnapshot","getDocs","leaderboard","data","isCurrentUserAdmin","getAllUsers","filters","cacheKey","cached","constraints","users","getAllUsersPaginated","pageSize","lastDoc","startAfter","newLastDoc","hasMore","index","updateUserRole","userId","newRole","getUsersStats","stats","u","oneWeekAgo","MONTH_NAMES","MONTH_NAMES_LOWERCASE","getCurrentMonthIndex","getCurrentMonthNumber","getCurrentYear","normalizeMonthFormat","month","year","monthName","monthLower","monthIndex","m","monthPart","monthIdx","yearPart","createMonthlyProgressId","normalizedMonth","extractYearFromMonth","saveQuizResult","quizData","score","resultData","resultRef","userService","updateMonthlyProgress","progressId","progressRef","progressData","getAnnualProgress","progress","dataYear","getQuestions","questions","createQuestion","questionData","newQuestion","opt","questionRef","deleteQuestion","questionId","deleteDoc","importQuestionsFromJSON","jsonData","importedIds","errors","question","err","getQuestionsStats","StateManager","keys","k","silent","oldValue","lastKey","target","updates","callback","callbacks","newValue","snapshot","stateManager"],"ignoreList":[],"sources":["../../js/client-manager.js","../../js/services/cache-service.js","../../js/services/audit-service.js","../../js/services/user-service.js","../../js/month-utils.js","../../js/services/quiz-service.js","../../js/services/question-service.js","../../js/state-manager.js"],"sourcesContent":["/**\r\n * Gestionnaire Multi-Tenant - Isolation des donn√©es par client\r\n * \r\n * Ce module g√®re l'isolation des donn√©es entre diff√©rents clients.\r\n * Chaque utilisateur appartient √† un client, et toutes les donn√©es\r\n * sont filtr√©es par clientId pour garantir l'isolation.\r\n * \r\n * ‚úÖ CORRECTION SECTION 1 : Isolation Multi-Tenant\r\n */\r\n\r\nimport { auth } from './firebase-config.js';\r\nimport { doc, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\r\nimport { db } from './firebase-config.js';\r\nimport { safeFirestoreRead } from './rate-limiter.js';\r\n\r\n// Client ID par d√©faut pour les utilisateurs existants (r√©tro-compatibilit√©)\r\nconst DEFAULT_CLIENT_ID = 'default';\r\n\r\n// Cache du clientId de l'utilisateur actuel\r\nlet currentUserClientId = null;\r\nlet clientIdCacheExpiry = 0;\r\nconst CLIENT_ID_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\n/**\r\n * R√©cup√®re le clientId de l'utilisateur actuel\r\n * @param {Object} user - L'objet utilisateur Firebase (optionnel, utilise auth.currentUser si non fourni)\r\n * @returns {Promise<string>} Le clientId de l'utilisateur\r\n */\r\nexport async function getCurrentClientId(user = null) {\r\n    const currentUser = user || auth.currentUser;\r\n    if (!currentUser) {\r\n        console.warn('‚ö†Ô∏è Aucun utilisateur connect√©, utilisation du clientId par d√©faut');\r\n        return DEFAULT_CLIENT_ID;\r\n    }\r\n\r\n    // V√©rifier le cache\r\n    const now = Date.now();\r\n    if (currentUserClientId && now < clientIdCacheExpiry) {\r\n        return currentUserClientId;\r\n    }\r\n\r\n    try {\r\n        // R√©cup√©rer le profil utilisateur pour obtenir le clientId\r\n        const userRef = doc(db, 'users', currentUser.uid);\r\n        const userDoc = await safeFirestoreRead(() => getDoc(userRef));\r\n\r\n        if (userDoc.exists()) {\r\n            const userData = userDoc.data();\r\n            // Si le clientId n'existe pas, d√©terminer √† partir de l'email ou utiliser le d√©faut\r\n            let clientId = userData.clientId;\r\n            if (!clientId) {\r\n                clientId = determineClientIdFromEmail(currentUser.email);\r\n            }\r\n            \r\n            // Mettre en cache\r\n            currentUserClientId = clientId;\r\n            clientIdCacheExpiry = now + CLIENT_ID_CACHE_TTL;\r\n            \r\n            return clientId;\r\n        } else {\r\n            // Utilisateur n'existe pas encore, d√©terminer √† partir de l'email\r\n            const clientId = determineClientIdFromEmail(currentUser.email);\r\n            console.log('üîÑ Profil utilisateur non trouv√©, clientId d√©termin√© √† partir de l\\'email:', clientId);\r\n            return clientId;\r\n        }\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration clientId:', error);\r\n        // En cas d'erreur, d√©terminer √† partir de l'email ou utiliser le d√©faut\r\n        const clientId = determineClientIdFromEmail(currentUser.email);\r\n        return clientId;\r\n    }\r\n}\r\n\r\n/**\r\n * R√©cup√®re le clientId de mani√®re synchrone (depuis le cache)\r\n * Retourne null si le cache n'est pas disponible\r\n * @returns {string|null} Le clientId ou null\r\n */\r\nexport function getCurrentClientIdSync() {\r\n    if (currentUserClientId && Date.now() < clientIdCacheExpiry) {\r\n        return currentUserClientId;\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * R√©initialise le cache du clientId\r\n * Utile apr√®s une mise √† jour du profil utilisateur\r\n */\r\nexport function resetClientIdCache() {\r\n    currentUserClientId = null;\r\n    clientIdCacheExpiry = 0;\r\n}\r\n\r\n/**\r\n * D√©termine le clientId √† partir de l'email (pour migration future)\r\n * @param {string} email - L'email de l'utilisateur\r\n * @returns {string} Le clientId d√©termin√©\r\n */\r\nexport function determineClientIdFromEmail(email) {\r\n    if (!email) return DEFAULT_CLIENT_ID;\r\n    \r\n    // Exemple de logique : extraire le domaine\r\n    // Pour l'instant, tous les utilisateurs utilisent le clientId par d√©faut\r\n    // Cette fonction peut √™tre √©tendue pour supporter plusieurs clients\r\n    const domain = email.split('@')[1];\r\n    \r\n    // Mapping de domaines vers clientIds (√† configurer selon les besoins)\r\n    const domainToClientId = {\r\n        // Exemple:\r\n        // 'client1.com': 'client1',\r\n        // 'client2.com': 'client2',\r\n    };\r\n    \r\n    return domainToClientId[domain] || DEFAULT_CLIENT_ID;\r\n}\r\n\r\n/**\r\n * V√©rifie si l'utilisateur actuel appartient √† un client sp√©cifique\r\n * @param {string} clientId - Le clientId √† v√©rifier\r\n * @returns {Promise<boolean>} True si l'utilisateur appartient au client\r\n */\r\nexport async function belongsToClient(clientId) {\r\n    const currentClientId = await getCurrentClientId();\r\n    return currentClientId === clientId;\r\n}\r\n\r\n/**\r\n * Ajoute un filtre clientId √† une requ√™te Firestore\r\n * @param {Query} query - La requ√™te Firestore\r\n * @param {string} clientId - Le clientId √† filtrer (optionnel, utilise l'utilisateur actuel si non fourni)\r\n * @returns {Promise<Query>} La requ√™te avec le filtre clientId\r\n */\r\nexport async function addClientIdFilter(query, clientId = null) {\r\n    // Cette fonction sera utilis√©e dans les requ√™tes Firestore\r\n    // Pour l'instant, on retourne la requ√™te telle quelle\r\n    // L'impl√©mentation compl√®te n√©cessitera de modifier toutes les requ√™tes\r\n    // dans firestore-service.js pour ajouter where('clientId', '==', clientId)\r\n    \r\n    if (!clientId) {\r\n        clientId = await getCurrentClientId();\r\n    }\r\n    \r\n    // Note: Cette fonction n√©cessite d'√™tre appel√©e avec une requ√™te qui peut √™tre modifi√©e\r\n    // L'impl√©mentation compl√®te sera faite dans firestore-service.js\r\n    return query;\r\n}\r\n\r\nexport default {\r\n    getCurrentClientId,\r\n    getCurrentClientIdSync,\r\n    resetClientIdCache,\r\n    determineClientIdFromEmail,\r\n    belongsToClient,\r\n    addClientIdFilter,\r\n    DEFAULT_CLIENT_ID\r\n};\r\n\r\n","/**\r\n * Service de Cache Centralis√©\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction du syst√®me de cache\r\n * ‚úÖ CORRECTION SECTION 6 : Am√©lioration - TTL configurable par type et invalidation intelligente\r\n * \r\n * G√®re le cache en m√©moire avec TTL configurable par type de donn√©es\r\n */\r\n\r\n// Cache en m√©moire pour limiter les lectures Firestore r√©p√©t√©es\r\nconst cacheStore = new Map();\r\n\r\n// ‚úÖ CORRECTION SECTION 6 : TTL configurable par type de donn√©es\r\nconst CACHE_CONFIG = {\r\n    users: 10 * 60 * 1000,        // 10 minutes\r\n    quizResults: 5 * 60 * 1000,  // 5 minutes\r\n    questions: 30 * 60 * 1000,     // 30 minutes\r\n    stats: 2 * 60 * 1000,          // 2 minutes\r\n    monthlyProgress: 10 * 60 * 1000, // 10 minutes\r\n    annualProgress: 15 * 60 * 1000,  // 15 minutes\r\n    default: 5 * 60 * 1000        // 5 minutes par d√©faut\r\n};\r\n\r\n/**\r\n * Obtenir le TTL pour un type de donn√©es\r\n * @param {string} dataType - Type de donn√©es (users, quizResults, questions, stats, etc.)\r\n * @returns {number} TTL en millisecondes\r\n */\r\nfunction getTTLForDataType(dataType) {\r\n    return CACHE_CONFIG[dataType] || CACHE_CONFIG.default;\r\n}\r\n\r\n/**\r\n * Construire une cl√© de cache √† partir de parties\r\n * @param {Array} parts - Parties de la cl√©\r\n * @returns {string} Cl√© de cache\r\n */\r\nexport function buildCacheKey(parts = []) {\r\n    return parts.filter(Boolean).join('::');\r\n}\r\n\r\n/**\r\n * Obtenir une valeur du cache\r\n * @param {string} key - Cl√© de cache\r\n * @returns {*} Valeur en cache ou null\r\n */\r\nexport function getCachedValue(key) {\r\n    const entry = cacheStore.get(key);\r\n    if (!entry) {\r\n        return null;\r\n    }\r\n    if (Date.now() > entry.expireAt) {\r\n        cacheStore.delete(key);\r\n        return null;\r\n    }\r\n    return entry.value;\r\n}\r\n\r\n/**\r\n * D√©finir une valeur dans le cache\r\n * @param {string} key - Cl√© de cache\r\n * @param {*} value - Valeur √† mettre en cache\r\n * @param {number|string} ttlMsOrType - Dur√©e de vie en millisecondes OU type de donn√©es pour TTL automatique\r\n */\r\nexport function setCachedValue(key, value, ttlMsOrType = CACHE_CONFIG.default) {\r\n    // ‚úÖ CORRECTION SECTION 6 : Si ttlMsOrType est une string, utiliser le TTL configur√© pour ce type\r\n    const ttlMs = typeof ttlMsOrType === 'string' \r\n        ? getTTLForDataType(ttlMsOrType)\r\n        : ttlMsOrType;\r\n    \r\n    cacheStore.set(key, {\r\n        value,\r\n        expireAt: Date.now() + ttlMs,\r\n        dataType: typeof ttlMsOrType === 'string' ? ttlMsOrType : null\r\n    });\r\n}\r\n\r\n/**\r\n * Invalider le cache par pr√©fixe\r\n * @param {string} prefix - Pr√©fixe des cl√©s √† invalider\r\n */\r\nexport function invalidateCache(prefix) {\r\n    cacheStore.forEach((_, key) => {\r\n        if (key.startsWith(prefix)) {\r\n            cacheStore.delete(key);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 6 : Invalidation intelligente par type de donn√©es\r\n * @param {string} dataType - Type de donn√©es √† invalider (users, quizResults, questions, stats, etc.)\r\n */\r\nexport function invalidateByDataType(dataType) {\r\n    cacheStore.forEach((entry, key) => {\r\n        if (entry.dataType === dataType || key.includes(dataType)) {\r\n            cacheStore.delete(key);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 6 : Invalidation intelligente bas√©e sur les √©v√©nements\r\n * @param {string} event - √âv√©nement d√©clench√© (quizCompleted, userUpdated, questionCreated, etc.)\r\n */\r\nexport function invalidateByEvent(event) {\r\n    const eventMap = {\r\n        'quizCompleted': ['quizResults', 'stats', 'monthlyProgress', 'annualProgress'],\r\n        'userUpdated': ['users', 'stats'], // ‚úÖ CORRECTION : Invalider aussi 'stats' pour userUpdated\r\n        'questionCreated': ['questions', 'questions-stats'],\r\n        'questionUpdated': ['questions', 'questions-stats'],\r\n        'questionDeleted': ['questions', 'questions-stats'],\r\n        'userRoleUpdated': ['users', 'stats'] // ‚úÖ CORRECTION : Invalider aussi 'stats' pour userRoleUpdated\r\n    };\r\n    \r\n    const typesToInvalidate = eventMap[event] || [];\r\n    typesToInvalidate.forEach(type => {\r\n        invalidateByDataType(type);\r\n    });\r\n}\r\n\r\n/**\r\n * Vider tout le cache\r\n */\r\nexport function clearCache() {\r\n    cacheStore.clear();\r\n}\r\n\r\n/**\r\n * Obtenir la taille du cache\r\n * @returns {number} Nombre d'entr√©es en cache\r\n */\r\nexport function getCacheSize() {\r\n    return cacheStore.size;\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 6 : Obtenir les statistiques du cache\r\n * @returns {Object} Statistiques du cache\r\n */\r\nexport function getCacheStats() {\r\n    const stats = {\r\n        total: cacheStore.size, // ‚úÖ CORRECTION : Utiliser 'total' au lieu de 'totalEntries'\r\n        totalEntries: cacheStore.size, // Garder pour compatibilit√©\r\n        byDataType: {}, // ‚úÖ CORRECTION : Utiliser 'byDataType' au lieu de 'byType'\r\n        byType: {}, // Garder pour compatibilit√©\r\n        expiredEntries: 0\r\n    };\r\n    \r\n    const now = Date.now();\r\n    cacheStore.forEach((entry, key) => {\r\n        if (entry.expireAt < now) {\r\n            stats.expiredEntries++;\r\n        }\r\n        \r\n        const type = entry.dataType || 'unknown';\r\n        stats.byDataType[type] = (stats.byDataType[type] || 0) + 1;\r\n        stats.byType[type] = (stats.byType[type] || 0) + 1; // Garder pour compatibilit√©\r\n    });\r\n    \r\n    return stats;\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 6 : Nettoyer les entr√©es expir√©es\r\n * @returns {number} Nombre d'entr√©es supprim√©es\r\n */\r\nexport function cleanExpiredEntries() {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n    \r\n    cacheStore.forEach((entry, key) => {\r\n        if (entry.expireAt < now) {\r\n            cacheStore.delete(key);\r\n            cleaned++;\r\n        }\r\n    });\r\n    \r\n    return cleaned;\r\n}\r\n","/**\r\n * Service d'Audit et de Logs\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions d'audit\r\n */\r\n\r\nimport { db } from '../firebase-config.js';\r\nimport { collection, addDoc, Timestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\r\nimport { safeFirestoreWrite } from '../rate-limiter.js';\r\n\r\n/**\r\n * ADMIN: Cr√©er un log d'import\r\n */\r\nexport async function createImportLog(logData) {\r\n    try {\r\n        const log = {\r\n            ...logData,\r\n            importedAt: Timestamp.now()\r\n        };\r\n        \r\n        // ‚úÖ CORRECTION SECTION 4 : Rate limiting pour les √©critures\r\n        await safeFirestoreWrite(() => addDoc(collection(db, 'importLogs'), log));\r\n        console.log('Log import cree');\r\n    } catch (error) {\r\n        console.error('Erreur creation log import:', error);\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Cr√©er un log d'audit\r\n */\r\nexport async function createAuditLog(logData) {\r\n    try {\r\n        const log = {\r\n            ...logData,\r\n            timestamp: Timestamp.now()\r\n        };\r\n        \r\n        // ‚úÖ CORRECTION SECTION 4 : Rate limiting pour les √©critures\r\n        await safeFirestoreWrite(() => addDoc(collection(db, 'auditLogs'), log));\r\n        console.log('Log audit cree');\r\n    } catch (error) {\r\n        console.error('Erreur creation log audit:', error);\r\n    }\r\n}\r\n\r\n","/**\r\n * Service de Gestion des Utilisateurs\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions utilisateurs\r\n */\r\n\r\nimport { db, auth } from '../firebase-config.js';\r\nimport { \r\n    collection, \r\n    doc, \r\n    getDoc, \r\n    getDocs, \r\n    setDoc, \r\n    updateDoc,\r\n    query,\r\n    where,\r\n    orderBy,\r\n    limit,\r\n    startAfter,\r\n    Timestamp,\r\n    runTransaction\r\n} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\r\nimport { safeFirestoreRead, safeFirestoreWrite } from '../rate-limiter.js';\r\nimport { getCurrentClientId } from '../client-manager.js';\r\nimport { buildCacheKey, getCachedValue, setCachedValue, invalidateCache } from './cache-service.js';\r\nimport { createAuditLog } from './audit-service.js';\r\n\r\nconst COLLECTIONS = {\r\n    users: 'users'\r\n};\r\n\r\n/**\r\n * Cr√©er ou mettre √† jour le profil utilisateur\r\n */\r\nexport async function createOrUpdateUser(user) {\r\n    try {\r\n        const userRef = doc(db, COLLECTIONS.users, user.uid);\r\n        // ‚úÖ CORRECTION SECTION 1 : R√©cup√©rer le clientId pour isolation multi-tenant\r\n        const clientId = await getCurrentClientId(user);\r\n        \r\n        const userData = {\r\n            uid: user.uid,\r\n            email: user.email,\r\n            displayName: user.displayName,\r\n            photoURL: user.photoURL,\r\n            lastLogin: Timestamp.now(),\r\n            updatedAt: Timestamp.now(),\r\n            clientId: clientId\r\n        };\r\n        \r\n        const userDoc = await safeFirestoreRead(() => getDoc(userRef));\r\n        \r\n        if (!userDoc.exists()) {\r\n            userData.createdAt = Timestamp.now();\r\n            userData.totalQuizzes = 0;\r\n            userData.averageScore = 0;\r\n            userData.currentStreak = 0;\r\n            userData.longestStreak = 0;\r\n            userData.role = 'user';\r\n            console.log('üë§ Cr√©ation du profil utilisateur:', user.email);\r\n        } else {\r\n            const existingData = userDoc.data();\r\n            if (!existingData.clientId) {\r\n                userData.clientId = clientId;\r\n                console.log('üîÑ Migration: Ajout du clientId au profil utilisateur existant');\r\n            }\r\n        }\r\n        \r\n        await safeFirestoreWrite(() => setDoc(userRef, userData, { merge: true }));\r\n        console.log('‚úÖ Profil utilisateur sauvegard√©');\r\n        return userData;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur cr√©ation utilisateur:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * R√©cup√©rer le profil utilisateur\r\n */\r\nexport async function getUserProfile(uid) {\r\n    try {\r\n        const userRef = doc(db, COLLECTIONS.users, uid);\r\n        const userDoc = await safeFirestoreRead(() => getDoc(userRef));\r\n        \r\n        if (userDoc.exists()) {\r\n            return userDoc.data();\r\n        }\r\n        return null;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration profil:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Mettre √† jour les statistiques utilisateur\r\n * Note: Cette fonction est utilis√©e par quiz-service.js, donc elle doit √™tre export√©e\r\n */\r\nexport async function updateUserStats(uid, newScore) {\r\n    if (isNaN(newScore) || newScore < 0 || newScore > 100) {\r\n        console.error('‚ùå Score invalide pour mise √† jour des stats:', newScore);\r\n        throw new Error(`Score invalide: ${newScore}. Doit √™tre entre 0 et 100.`);\r\n    }\r\n    \r\n    try {\r\n        await runTransaction(db, async (transaction) => {\r\n            const userRef = doc(db, COLLECTIONS.users, uid);\r\n            const userDoc = await transaction.get(userRef);\r\n            \r\n            if (!userDoc.exists()) {\r\n                throw new Error('Utilisateur non trouv√©');\r\n            }\r\n            \r\n            const userData = userDoc.data();\r\n            const totalQuizzes = (userData.totalQuizzes || 0) + 1;\r\n            const currentAverage = userData.averageScore || 0;\r\n            const newAverage = ((currentAverage * (totalQuizzes - 1)) + newScore) / totalQuizzes;\r\n            \r\n            const roundedAverage = Math.round(newAverage);\r\n            if (isNaN(roundedAverage) || roundedAverage < 0 || roundedAverage > 100) {\r\n                console.error('‚ùå Moyenne calcul√©e invalide:', roundedAverage);\r\n                throw new Error(`Erreur de calcul de la moyenne: ${roundedAverage}`);\r\n            }\r\n            \r\n            transaction.update(userRef, {\r\n                totalQuizzes: totalQuizzes,\r\n                averageScore: roundedAverage,\r\n                lastQuizDate: Timestamp.now(),\r\n                updatedAt: Timestamp.now()\r\n            });\r\n        });\r\n        \r\n        console.log('üìä Statistiques mises √† jour');\r\n        invalidateCache('users');\r\n        invalidateCache('users-stats');\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur mise √† jour statistiques:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Calculer et mettre √† jour la s√©rie (streak)\r\n */\r\nexport async function updateStreak(uid) {\r\n    // Import dynamique pour √©viter d√©pendance circulaire\r\n    const { getUserQuizResults } = await import('./quiz-service.js');\r\n    \r\n    try {\r\n        const results = await getUserQuizResults(uid, 12);\r\n        \r\n        let currentStreak = 0;\r\n        const monthsSet = new Set();\r\n        \r\n        for (const result of results) {\r\n            if (result.score >= 60) {\r\n                monthsSet.add(result.month);\r\n            }\r\n        }\r\n        \r\n        const months = Array.from(monthsSet).sort().reverse();\r\n        for (let i = 0; i < months.length; i++) {\r\n            currentStreak++;\r\n            if (i < months.length - 1) {\r\n                // Logique de v√©rification de cons√©cutivit√© simplifi√©e\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        const userRef = doc(db, COLLECTIONS.users, uid);\r\n        const userDoc = await safeFirestoreRead(() => getDoc(userRef));\r\n        \r\n        if (userDoc.exists()) {\r\n            const userData = userDoc.data();\r\n            const longestStreak = Math.max(currentStreak, userData.longestStreak || 0);\r\n            \r\n            await safeFirestoreWrite(() => updateDoc(userRef, {\r\n                currentStreak: currentStreak,\r\n                longestStreak: longestStreak,\r\n                updatedAt: Timestamp.now()\r\n            }));\r\n            \r\n            console.log(`üî• S√©rie mise √† jour: ${currentStreak} mois`);\r\n            invalidateCache('users');\r\n            invalidateCache('users-stats');\r\n        }\r\n        \r\n        return currentStreak;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur mise √† jour s√©rie:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * R√©cup√©rer le classement g√©n√©ral\r\n */\r\nexport async function getLeaderboard(limitCount = 10) {\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const q = query(\r\n            collection(db, COLLECTIONS.users),\r\n            where('clientId', '==', clientId),\r\n            orderBy('averageScore', 'desc'),\r\n            orderBy('totalQuizzes', 'desc'),\r\n            limit(limitCount)\r\n        );\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const leaderboard = [];\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            const data = doc.data();\r\n            leaderboard.push({\r\n                uid: doc.id,\r\n                displayName: data.displayName,\r\n                photoURL: data.photoURL,\r\n                averageScore: data.averageScore,\r\n                totalQuizzes: data.totalQuizzes,\r\n                currentStreak: data.currentStreak\r\n            });\r\n        });\r\n        \r\n        console.log('üèÜ Classement charg√©');\r\n        return leaderboard;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration classement:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * V√©rifier si l'utilisateur actuel est admin\r\n */\r\nexport async function isCurrentUserAdmin() {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) return false;\r\n        \r\n        const userProfile = await getUserProfile(user.uid);\r\n        return userProfile?.role === 'admin';\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur v√©rification admin:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: R√©cup√©rer tous les utilisateurs (sans pagination - pour compatibilit√©)\r\n */\r\nexport async function getAllUsers(filters = {}) {\r\n    const cacheKey = buildCacheKey(['users', JSON.stringify(filters || {})]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const constraints = [\r\n            where('clientId', '==', clientId)\r\n        ];\r\n        \r\n        if (filters.role) {\r\n            constraints.push(where('role', '==', filters.role));\r\n        }\r\n        \r\n        constraints.push(orderBy('createdAt', 'desc'));\r\n        \r\n        const q = query(collection(db, COLLECTIONS.users), ...constraints);\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const users = [];\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            users.push({ id: doc.id, ...doc.data() });\r\n        });\r\n        \r\n        console.log(`üë• ${users.length} utilisateurs charg√©s`);\r\n        setCachedValue(cacheKey, users, 'users');\r\n        return users;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration utilisateurs:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 7 : Pagination - R√©cup√©rer les utilisateurs avec pagination\r\n * @param {Object} filters - Filtres optionnels\r\n * @param {number} pageSize - Nombre d'√©l√©ments par page (d√©faut: 20)\r\n * @param {QueryDocumentSnapshot|null} lastDoc - Document de d√©part pour la pagination\r\n * @returns {Promise<{users: Array, lastDoc: QueryDocumentSnapshot|null, hasMore: boolean}>}\r\n */\r\nexport async function getAllUsersPaginated(filters = {}, pageSize = 20, lastDoc = null) {\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const constraints = [\r\n            where('clientId', '==', clientId)\r\n        ];\r\n        \r\n        if (filters.role) {\r\n            constraints.push(where('role', '==', filters.role));\r\n        }\r\n        \r\n        constraints.push(orderBy('createdAt', 'desc'));\r\n        constraints.push(limit(pageSize + 1)); // +1 pour d√©tecter s'il y a plus de r√©sultats\r\n        \r\n        let q = query(collection(db, COLLECTIONS.users), ...constraints);\r\n        \r\n        // Si on a un document de d√©part, commencer apr√®s\r\n        if (lastDoc) {\r\n            q = query(q, startAfter(lastDoc));\r\n        }\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const users = [];\r\n        let newLastDoc = null;\r\n        let hasMore = false;\r\n        \r\n        querySnapshot.forEach((doc, index) => {\r\n            if (index < pageSize) {\r\n                users.push({ id: doc.id, ...doc.data() });\r\n            } else {\r\n                // On a r√©cup√©r√© un √©l√©ment de plus, donc il y a plus de r√©sultats\r\n                hasMore = true;\r\n            }\r\n        });\r\n        \r\n        // Le dernier document de cette page devient le curseur pour la suivante\r\n        if (querySnapshot.docs.length > 0 && users.length === pageSize) {\r\n            newLastDoc = querySnapshot.docs[pageSize - 1];\r\n        }\r\n        \r\n        console.log(`üë• ${users.length} utilisateurs charg√©s (pagination)`);\r\n        return {\r\n            users,\r\n            lastDoc: newLastDoc,\r\n            hasMore\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration utilisateurs pagin√©s:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Mettre √† jour le r√¥le d'un utilisateur\r\n */\r\nexport async function updateUserRole(userId, newRole) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        if (!['user', 'admin'].includes(newRole)) {\r\n            throw new Error('R√¥le invalide - doit √™tre \"user\" ou \"admin\"');\r\n        }\r\n        \r\n        const userRef = doc(db, COLLECTIONS.users, userId);\r\n        \r\n        await safeFirestoreWrite(() => updateDoc(userRef, {\r\n            role: newRole,\r\n            updatedAt: Timestamp.now()\r\n        }));\r\n        \r\n        console.log(`‚úÖ R√¥le mis √† jour pour ${userId}: ${newRole}`);\r\n        \r\n        await createAuditLog({\r\n            action: 'UPDATE_USER_ROLE',\r\n            targetUserId: userId,\r\n            newRole: newRole,\r\n            adminId: user.uid,\r\n            adminEmail: user.email\r\n        });\r\n\r\n        invalidateCache('users');\r\n        invalidateCache('users-stats');\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur mise √† jour r√¥le:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: R√©cup√©rer les statistiques des utilisateurs\r\n */\r\nexport async function getUsersStats() {\r\n    const clientId = await getCurrentClientId();\r\n    const cacheKey = buildCacheKey(['users-stats', clientId]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const users = await getAllUsers();\r\n        \r\n        const stats = {\r\n            total: users.length,\r\n            admins: users.filter(u => u.role === 'admin').length,\r\n            regularUsers: users.filter(u => u.role !== 'admin').length,\r\n            activeLastWeek: 0,\r\n            averageScore: 0,\r\n            totalQuizzes: 0\r\n        };\r\n        \r\n        const oneWeekAgo = new Date();\r\n        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\r\n        \r\n        users.forEach(u => {\r\n            if (u.lastLogin && u.lastLogin.toDate() > oneWeekAgo) {\r\n                stats.activeLastWeek++;\r\n            }\r\n            stats.totalQuizzes += (u.totalQuizzes || 0);\r\n            stats.averageScore += (u.averageScore || 0);\r\n        });\r\n        \r\n        stats.averageScore = stats.total > 0 ? Math.round(stats.averageScore / stats.total) : 0;\r\n        \r\n        setCachedValue(cacheKey, stats, 'stats');\r\n        return stats;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur statistiques utilisateurs:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n","/**\r\n * Utilitaires pour la gestion des mois (Section 2 - Logique M√©tier)\r\n * \r\n * Ce module fournit des fonctions pour normaliser et g√©rer les formats de mois\r\n * afin d'√©viter les incoh√©rences entre dashboard et quiz.\r\n */\r\n\r\n/**\r\n * Noms des mois en fran√ßais (premi√®re lettre majuscule)\r\n */\r\nexport const MONTH_NAMES = [\r\n    'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',\r\n    'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'\r\n];\r\n\r\n/**\r\n * Noms des mois en minuscules (pour compatibilit√©)\r\n */\r\nexport const MONTH_NAMES_LOWERCASE = [\r\n    'janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin',\r\n    'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'\r\n];\r\n\r\n/**\r\n * Obtient l'index du mois actuel (0-11)\r\n * @returns {number} Index du mois actuel (0 = Janvier, 11 = D√©cembre)\r\n */\r\nexport function getCurrentMonthIndex() {\r\n    const now = new Date();\r\n    return now.getMonth(); // 0-11\r\n}\r\n\r\n/**\r\n * Obtient le num√©ro du mois actuel (1-12)\r\n * @returns {number} Num√©ro du mois actuel (1 = Janvier, 12 = D√©cembre)\r\n */\r\nexport function getCurrentMonthNumber() {\r\n    return getCurrentMonthIndex() + 1;\r\n}\r\n\r\n/**\r\n * Obtient l'ann√©e actuelle\r\n * @returns {number} Ann√©e actuelle\r\n */\r\nexport function getCurrentYear() {\r\n    return new Date().getFullYear();\r\n}\r\n\r\n/**\r\n * Normalise le format d'un mois pour garantir la coh√©rence\r\n * \r\n * Format de sortie garanti : \"Novembre 2025\" (premi√®re lettre majuscule, espace, ann√©e)\r\n * \r\n * @param {string|number} month - Mois (texte ou num√©ro 1-12)\r\n * @param {number} year - Ann√©e (optionnel, utilise l'ann√©e actuelle par d√©faut)\r\n * @returns {string} Mois normalis√© au format \"Novembre 2025\"\r\n */\r\nexport function normalizeMonthFormat(month, year = getCurrentYear()) {\r\n    let monthName;\r\n    \r\n    // Si c'est un num√©ro (1-12)\r\n    if (typeof month === 'number') {\r\n        if (month < 1 || month > 12) {\r\n            throw new Error(`Num√©ro de mois invalide: ${month}. Doit √™tre entre 1 et 12.`);\r\n        }\r\n        monthName = MONTH_NAMES[month - 1];\r\n    }\r\n    // Si c'est une cha√Æne\r\n    else if (typeof month === 'string') {\r\n        // Normaliser la casse\r\n        const monthLower = month.toLowerCase().trim();\r\n        \r\n        // Chercher dans la liste des mois en minuscules\r\n        const monthIndex = MONTH_NAMES_LOWERCASE.findIndex(m => m === monthLower);\r\n        if (monthIndex !== -1) {\r\n            monthName = MONTH_NAMES[monthIndex];\r\n        } else {\r\n            // Essayer de parser un format comme \"novembre 2025\" ou \"Novembre 2025\"\r\n            const parts = month.split(' ');\r\n            if (parts.length >= 1) {\r\n                const monthPart = parts[0].toLowerCase();\r\n                const monthIdx = MONTH_NAMES_LOWERCASE.findIndex(m => m === monthPart);\r\n                if (monthIdx !== -1) {\r\n                    monthName = MONTH_NAMES[monthIdx];\r\n                    // Si l'ann√©e est dans la cha√Æne, l'utiliser\r\n                    if (parts.length >= 2) {\r\n                        const yearPart = parseInt(parts[1]);\r\n                        if (!isNaN(yearPart)) {\r\n                            year = yearPart;\r\n                        }\r\n                    }\r\n                } else {\r\n                    throw new Error(`Format de mois invalide: ${month}`);\r\n                }\r\n            } else {\r\n                throw new Error(`Format de mois invalide: ${month}`);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`Type de mois invalide: ${typeof month}`);\r\n    }\r\n    \r\n    return `${monthName} ${year}`;\r\n}\r\n\r\n/**\r\n * Cr√©e un ID de document Firestore pour monthlyProgress\r\n * Remplace les espaces par des underscores pour √©viter les probl√®mes\r\n * \r\n * @param {string} userId - ID de l'utilisateur\r\n * @param {string|number} month - Mois (texte ou num√©ro)\r\n * @param {number} year - Ann√©e (optionnel)\r\n * @returns {string} ID du document au format \"userId_Novembre_2025\"\r\n */\r\nexport function createMonthlyProgressId(userId, month, year = getCurrentYear()) {\r\n    const normalizedMonth = normalizeMonthFormat(month, year);\r\n    // Remplacer les espaces par des underscores pour l'ID Firestore\r\n    return `${userId}_${normalizedMonth.replace(/\\s+/g, '_')}`;\r\n}\r\n\r\n/**\r\n * Extrait l'ann√©e d'une cha√Æne de mois normalis√©e\r\n * \r\n * @param {string} normalizedMonth - Mois normalis√© au format \"Novembre 2025\"\r\n * @returns {number} Ann√©e extraite\r\n */\r\nexport function extractYearFromMonth(normalizedMonth) {\r\n    const parts = normalizedMonth.split(' ');\r\n    if (parts.length >= 2) {\r\n        const year = parseInt(parts[parts.length - 1]);\r\n        if (!isNaN(year)) {\r\n            return year;\r\n        }\r\n    }\r\n    return getCurrentYear();\r\n}\r\n\r\n/**\r\n * Valide qu'un format de mois est correct\r\n * \r\n * @param {string} month - Mois √† valider\r\n * @returns {boolean} True si le format est valide\r\n */\r\nexport function isValidMonthFormat(month) {\r\n    try {\r\n        normalizeMonthFormat(month);\r\n        return true;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport default {\r\n    MONTH_NAMES,\r\n    MONTH_NAMES_LOWERCASE,\r\n    getCurrentMonthIndex,\r\n    getCurrentMonthNumber,\r\n    getCurrentYear,\r\n    normalizeMonthFormat,\r\n    createMonthlyProgressId,\r\n    extractYearFromMonth,\r\n    isValidMonthFormat\r\n};\r\n\r\n\r\n","/**\r\n * Service de Gestion des Quiz et R√©sultats\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions quiz\r\n */\r\n\r\nimport { db, auth } from '../firebase-config.js';\r\nimport { \r\n    collection, \r\n    doc, \r\n    getDocs, \r\n    addDoc,\r\n    setDoc,\r\n    query,\r\n    where,\r\n    orderBy,\r\n    limit,\r\n    startAfter,\r\n    Timestamp\r\n} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\r\nimport { safeFirestoreRead, safeFirestoreWrite } from '../rate-limiter.js';\r\nimport { getCurrentClientId } from '../client-manager.js';\r\nimport { normalizeMonthFormat, createMonthlyProgressId, extractYearFromMonth } from '../month-utils.js';\r\nimport { buildCacheKey, getCachedValue, setCachedValue, invalidateCache } from './cache-service.js';\r\n\r\nconst COLLECTIONS = {\r\n    quizResults: 'quizResults',\r\n    monthlyProgress: 'monthlyProgress'\r\n};\r\n\r\n/**\r\n * Sauvegarder un r√©sultat de quiz\r\n */\r\nexport async function saveQuizResult(quizData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        const score = quizData.score;\r\n        if (isNaN(score) || score < 0 || score > 100) {\r\n            throw new Error(`Score invalide: ${score}. Doit √™tre entre 0 et 100.`);\r\n        }\r\n        \r\n        if (!quizData.totalQuestions || quizData.totalQuestions <= 0) {\r\n            throw new Error(`Nombre total de questions invalide: ${quizData.totalQuestions}`);\r\n        }\r\n        if (quizData.correctAnswers < 0 || quizData.correctAnswers > quizData.totalQuestions) {\r\n            throw new Error(`Nombre de bonnes r√©ponses invalide: ${quizData.correctAnswers}`);\r\n        }\r\n        \r\n        const normalizedMonth = normalizeMonthFormat(quizData.month || new Date().getMonth() + 1, quizData.year || new Date().getFullYear());\r\n        const year = extractYearFromMonth(normalizedMonth);\r\n        \r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const resultData = {\r\n            userId: user.uid,\r\n            userEmail: user.email,\r\n            moduleId: quizData.moduleId,\r\n            moduleName: quizData.moduleName,\r\n            score: score,\r\n            correctAnswers: quizData.correctAnswers,\r\n            totalQuestions: quizData.totalQuestions,\r\n            timeElapsed: quizData.timeElapsed,\r\n            answers: quizData.answers,\r\n            date: Timestamp.now(),\r\n            completedAt: Timestamp.now(),\r\n            month: normalizedMonth,\r\n            year: year,\r\n            clientId: clientId\r\n        };\r\n        \r\n        const resultRef = await safeFirestoreWrite(() => \r\n            addDoc(collection(db, COLLECTIONS.quizResults), resultData)\r\n        );\r\n        console.log('‚úÖ R√©sultat de quiz sauvegard√©:', resultRef.id);\r\n        \r\n        // Import dynamique pour √©viter d√©pendance circulaire\r\n        const { updateUserStats } = await import('./user-service.js');\r\n        await updateUserStats(user.uid, quizData.score);\r\n        await updateMonthlyProgress(user.uid, quizData.month, quizData.score);\r\n\r\n        invalidateCache(buildCacheKey(['quizResults', user.uid]));\r\n        invalidateCache(buildCacheKey(['monthlyResults', user.uid]));\r\n        invalidateCache(buildCacheKey(['annualProgress', user.uid]));\r\n        invalidateCache('users');\r\n        invalidateCache('users-stats');\r\n        \r\n        return resultRef.id;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur sauvegarde r√©sultat:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * R√©cup√©rer tous les r√©sultats d'un utilisateur (sans pagination - pour compatibilit√©)\r\n */\r\nexport async function getUserQuizResults(uid, limitCount = 50) {\r\n    const cacheKey = buildCacheKey(['quizResults', uid, limitCount]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const q = query(\r\n            collection(db, COLLECTIONS.quizResults),\r\n            where('userId', '==', uid),\r\n            where('clientId', '==', clientId),\r\n            orderBy('date', 'desc'),\r\n            limit(limitCount)\r\n        );\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const results = [];\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            results.push({ id: doc.id, ...doc.data() });\r\n        });\r\n        \r\n        console.log(`üìä ${results.length} r√©sultats charg√©s`);\r\n        setCachedValue(cacheKey, results, 'quizResults');\r\n        return results;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration r√©sultats:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 7 : Pagination - R√©cup√©rer les r√©sultats d'un utilisateur avec pagination\r\n * @param {string} uid - ID de l'utilisateur\r\n * @param {number} pageSize - Nombre d'√©l√©ments par page (d√©faut: 20)\r\n * @param {QueryDocumentSnapshot|null} lastDoc - Document de d√©part pour la pagination\r\n * @returns {Promise<{results: Array, lastDoc: QueryDocumentSnapshot|null, hasMore: boolean}>}\r\n */\r\nexport async function getUserQuizResultsPaginated(uid, pageSize = 20, lastDoc = null) {\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const constraints = [\r\n            where('userId', '==', uid),\r\n            where('clientId', '==', clientId),\r\n            orderBy('date', 'desc'),\r\n            limit(pageSize + 1) // +1 pour d√©tecter s'il y a plus de r√©sultats\r\n        ];\r\n        \r\n        let q = query(collection(db, COLLECTIONS.quizResults), ...constraints);\r\n        \r\n        // Si on a un document de d√©part, commencer apr√®s\r\n        if (lastDoc) {\r\n            q = query(q, startAfter(lastDoc));\r\n        }\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const results = [];\r\n        let newLastDoc = null;\r\n        let hasMore = false;\r\n        \r\n        querySnapshot.forEach((doc, index) => {\r\n            if (index < pageSize) {\r\n                results.push({ id: doc.id, ...doc.data() });\r\n            } else {\r\n                hasMore = true;\r\n            }\r\n        });\r\n        \r\n        if (querySnapshot.docs.length > 0 && results.length === pageSize) {\r\n            newLastDoc = querySnapshot.docs[pageSize - 1];\r\n        }\r\n        \r\n        console.log(`üìä ${results.length} r√©sultats charg√©s (pagination)`);\r\n        return {\r\n            results,\r\n            lastDoc: newLastDoc,\r\n            hasMore\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration r√©sultats pagin√©s:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * R√©cup√©rer les r√©sultats d'un mois sp√©cifique\r\n */\r\nexport async function getMonthlyResults(uid, month) {\r\n    const cacheKey = buildCacheKey(['monthlyResults', uid, month]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const q = query(\r\n            collection(db, COLLECTIONS.quizResults),\r\n            where('userId', '==', uid),\r\n            where('month', '==', month),\r\n            where('clientId', '==', clientId),\r\n            orderBy('date', 'desc')\r\n        );\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const results = [];\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            results.push({ id: doc.id, ...doc.data() });\r\n        });\r\n        \r\n        setCachedValue(cacheKey, results, 'monthlyProgress');\r\n        return results;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration r√©sultats mensuels:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Mettre √† jour la progression mensuelle\r\n */\r\nexport async function updateMonthlyProgress(uid, month, score) {\r\n    try {\r\n        const normalizedMonth = normalizeMonthFormat(month);\r\n        const year = extractYearFromMonth(normalizedMonth);\r\n        \r\n        const progressId = createMonthlyProgressId(uid, normalizedMonth);\r\n        const progressRef = doc(db, COLLECTIONS.monthlyProgress, progressId);\r\n        \r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const progressData = {\r\n            userId: uid,\r\n            month: normalizedMonth,\r\n            year: year,\r\n            score: score,\r\n            completed: true,\r\n            completedAt: Timestamp.now(),\r\n            updatedAt: Timestamp.now(),\r\n            clientId: clientId\r\n        };\r\n        \r\n        await safeFirestoreWrite(() => setDoc(progressRef, progressData, { merge: true }));\r\n        console.log('‚úÖ Progression mensuelle mise √† jour:', { \r\n            userId: uid, \r\n            month: normalizedMonth, \r\n            score: score,\r\n            progressId \r\n        });\r\n\r\n        // ‚úÖ CRITIQUE: Invalider le cache de mani√®re exhaustive\r\n        invalidateCache(buildCacheKey(['monthlyResults', uid]));\r\n        invalidateCache(buildCacheKey(['annualProgress', uid, year]));\r\n        invalidateCache(buildCacheKey(['annualProgress', uid])); // Sans l'ann√©e aussi\r\n        console.log('üóëÔ∏è Cache invalid√© pour:', { uid, year });\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur mise √† jour progression:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * R√©cup√©rer la progression annuelle\r\n */\r\nexport async function getAnnualProgress(uid, year = new Date().getFullYear()) {\r\n    const cacheKey = buildCacheKey(['annualProgress', uid, year]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const q = query(\r\n            collection(db, COLLECTIONS.monthlyProgress),\r\n            where('userId', '==', uid),\r\n            where('clientId', '==', clientId)\r\n        );\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const progress = {};\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            const data = doc.data();\r\n            const dataYear = data.year || extractYearFromMonth(data.month);\r\n            if (dataYear === year) {\r\n                const normalizedMonth = normalizeMonthFormat(data.month, dataYear);\r\n                progress[normalizedMonth] = {\r\n                    ...data,\r\n                    month: normalizedMonth,\r\n                    year: dataYear\r\n                };\r\n            }\r\n        });\r\n        \r\n        console.log('üìÖ Progression annuelle charg√©e');\r\n        setCachedValue(cacheKey, progress, 'annualProgress');\r\n        return progress;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration progression:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n","/**\r\n * Service de Gestion des Questions\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions questions\r\n */\r\n\r\nimport { db, auth } from '../firebase-config.js';\r\nimport { \r\n    collection, \r\n    doc, \r\n    getDoc, \r\n    getDocs, \r\n    addDoc,\r\n    updateDoc,\r\n    deleteDoc,\r\n    query,\r\n    where,\r\n    orderBy,\r\n    limit,\r\n    startAfter,\r\n    Timestamp\r\n} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\r\nimport { safeFirestoreRead, safeFirestoreWrite } from '../rate-limiter.js';\r\nimport { getCurrentClientId } from '../client-manager.js';\r\nimport { buildCacheKey, getCachedValue, setCachedValue, invalidateCache } from './cache-service.js';\r\nimport { createAuditLog, createImportLog } from './audit-service.js';\r\n\r\nconst COLLECTIONS = {\r\n    questions: 'questions'\r\n};\r\n\r\n/**\r\n * ADMIN: R√©cup√©rer toutes les questions avec filtres optionnels (sans pagination - pour compatibilit√©)\r\n */\r\nexport async function getQuestions(filters = {}) {\r\n    const cacheKey = buildCacheKey(['questions', JSON.stringify(filters || {})]);\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        // ‚úÖ P0 CRITIQUE: Filtrer par clientId pour isolation multi-tenant\r\n        const clientId = await getCurrentClientId();\r\n        let q = collection(db, COLLECTIONS.questions);\r\n        const constraints = [where('clientId', '==', clientId)];\r\n        \r\n        if (filters.module) {\r\n            constraints.push(where('module', '==', filters.module));\r\n        }\r\n        if (filters.month) {\r\n            constraints.push(where('month', '==', filters.month));\r\n        }\r\n        if (filters.year) {\r\n            constraints.push(where('year', '==', filters.year));\r\n        }\r\n        \r\n        constraints.push(orderBy('createdAt', 'desc'));\r\n        \r\n        q = query(q, ...constraints);\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const questions = [];\r\n        \r\n        querySnapshot.forEach((doc) => {\r\n            questions.push({ id: doc.id, ...doc.data() });\r\n        });\r\n        \r\n        console.log(`üìö ${questions.length} questions charg√©es`);\r\n        setCachedValue(cacheKey, questions, 'questions');\r\n        return questions;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration questions:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ‚úÖ CORRECTION SECTION 7 : Pagination - R√©cup√©rer les questions avec pagination\r\n * @param {Object} filters - Filtres optionnels\r\n * @param {number} pageSize - Nombre d'√©l√©ments par page (d√©faut: 20)\r\n * @param {QueryDocumentSnapshot|null} lastDoc - Document de d√©part pour la pagination\r\n * @returns {Promise<{questions: Array, lastDoc: QueryDocumentSnapshot|null, hasMore: boolean}>}\r\n */\r\nexport async function getQuestionsPaginated(filters = {}, pageSize = 20, lastDoc = null) {\r\n    try {\r\n        // ‚úÖ P0 CRITIQUE: Filtrer par clientId pour isolation multi-tenant\r\n        const clientId = await getCurrentClientId();\r\n        let q = collection(db, COLLECTIONS.questions);\r\n        const constraints = [where('clientId', '==', clientId)];\r\n        \r\n        if (filters.module) {\r\n            constraints.push(where('module', '==', filters.module));\r\n        }\r\n        if (filters.month) {\r\n            constraints.push(where('month', '==', filters.month));\r\n        }\r\n        if (filters.year) {\r\n            constraints.push(where('year', '==', filters.year));\r\n        }\r\n        \r\n        constraints.push(orderBy('createdAt', 'desc'));\r\n        constraints.push(limit(pageSize + 1)); // +1 pour d√©tecter s'il y a plus de r√©sultats\r\n        \r\n        q = query(q, ...constraints);\r\n        \r\n        // Si on a un document de d√©part, commencer apr√®s\r\n        if (lastDoc) {\r\n            q = query(q, startAfter(lastDoc));\r\n        }\r\n        \r\n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\r\n        const questions = [];\r\n        let newLastDoc = null;\r\n        let hasMore = false;\r\n        \r\n        querySnapshot.forEach((doc, index) => {\r\n            if (index < pageSize) {\r\n                questions.push({ id: doc.id, ...doc.data() });\r\n            } else {\r\n                hasMore = true;\r\n            }\r\n        });\r\n        \r\n        if (querySnapshot.docs.length > 0 && questions.length === pageSize) {\r\n            newLastDoc = querySnapshot.docs[pageSize - 1];\r\n        }\r\n        \r\n        console.log(`üìö ${questions.length} questions charg√©es (pagination)`);\r\n        return {\r\n            questions,\r\n            lastDoc: newLastDoc,\r\n            hasMore\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur r√©cup√©ration questions pagin√©es:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Cr√©er une nouvelle question\r\n */\r\nexport async function createQuestion(questionData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        if (!questionData.question || questionData.question.length < 10) {\r\n            throw new Error('La question doit contenir au moins 10 caract√®res');\r\n        }\r\n        if (!questionData.options || questionData.options.length !== 4) {\r\n            throw new Error('La question doit avoir exactement 4 options');\r\n        }\r\n        if (questionData.correctAnswer === undefined || questionData.correctAnswer < 0 || questionData.correctAnswer > 3) {\r\n            throw new Error('La r√©ponse correcte doit √™tre entre 0 et 3');\r\n        }\r\n        if (!questionData.explanation || questionData.explanation.length < 20) {\r\n            throw new Error('L\\'explication doit contenir au moins 20 caract√®res');\r\n        }\r\n        if (!['auto', 'loisir', 'vr', 'tracteur'].includes(questionData.module)) {\r\n            throw new Error('Module invalide');\r\n        }\r\n        if (!questionData.month || questionData.month < 1 || questionData.month > 12) {\r\n            throw new Error('Mois invalide');\r\n        }\r\n        \r\n        // ‚úÖ P0 CRITIQUE: Ajouter clientId pour isolation multi-tenant\r\n        const clientId = await getCurrentClientId();\r\n        \r\n        const newQuestion = {\r\n            question: questionData.question.trim(),\r\n            options: questionData.options.map(opt => opt.trim()),\r\n            correctAnswer: parseInt(questionData.correctAnswer),\r\n            explanation: questionData.explanation.trim(),\r\n            module: questionData.module,\r\n            month: parseInt(questionData.month),\r\n            year: questionData.year || new Date().getFullYear(),\r\n            clientId: clientId, // ‚úÖ P0 CRITIQUE: Isolation multi-tenant\r\n            createdAt: Timestamp.now(),\r\n            createdBy: user.uid,\r\n            updatedAt: Timestamp.now()\r\n        };\r\n        \r\n        const questionRef = await safeFirestoreWrite(() => \r\n            addDoc(collection(db, COLLECTIONS.questions), newQuestion)\r\n        );\r\n        console.log('‚úÖ Question cr√©√©e:', questionRef.id);\r\n        \r\n        await createAuditLog({\r\n            action: 'CREATE_QUESTION',\r\n            questionId: questionRef.id,\r\n            adminId: user.uid,\r\n            adminEmail: user.email\r\n        });\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return questionRef.id;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur cr√©ation question:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Mettre √† jour une question existante\r\n */\r\nexport async function updateQuestion(questionId, questionData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        const questionRef = doc(db, COLLECTIONS.questions, questionId);\r\n        \r\n        const updatedData = {\r\n            ...questionData,\r\n            updatedAt: Timestamp.now()\r\n        };\r\n        \r\n        delete updatedData.createdAt;\r\n        delete updatedData.createdBy;\r\n        \r\n        await safeFirestoreWrite(() => updateDoc(questionRef, updatedData));\r\n        console.log('‚úÖ Question mise √† jour:', questionId);\r\n        \r\n        await createAuditLog({\r\n            action: 'UPDATE_QUESTION',\r\n            questionId: questionId,\r\n            adminId: user.uid,\r\n            adminEmail: user.email,\r\n            changes: questionData\r\n        });\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur mise √† jour question:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Supprimer une question\r\n */\r\nexport async function deleteQuestion(questionId) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        const questionRef = doc(db, COLLECTIONS.questions, questionId);\r\n        \r\n        const questionDoc = await safeFirestoreRead(() => getDoc(questionRef));\r\n        const questionData = questionDoc.data();\r\n        \r\n        await safeFirestoreWrite(() => deleteDoc(questionRef));\r\n        console.log('üóëÔ∏è Question supprim√©e:', questionId);\r\n        \r\n        await createAuditLog({\r\n            action: 'DELETE_QUESTION',\r\n            questionId: questionId,\r\n            adminId: user.uid,\r\n            adminEmail: user.email,\r\n            deletedData: questionData\r\n        });\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur suppression question:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: Importer des questions depuis JSON\r\n */\r\nexport async function importQuestionsFromJSON(jsonData) {\r\n    try {\r\n        const user = auth.currentUser;\r\n        if (!user) throw new Error('Utilisateur non connect√©');\r\n        \r\n        if (!jsonData.module || !jsonData.month || !jsonData.year || !jsonData.questions) {\r\n            throw new Error('Format JSON invalide - champs obligatoires manquants');\r\n        }\r\n        \r\n        if (!Array.isArray(jsonData.questions) || jsonData.questions.length === 0) {\r\n            throw new Error('Le fichier JSON doit contenir au moins une question');\r\n        }\r\n        \r\n        const importedIds = [];\r\n        const errors = [];\r\n        \r\n        for (let i = 0; i < jsonData.questions.length; i++) {\r\n            const question = jsonData.questions[i];\r\n            \r\n            try {\r\n                const questionData = {\r\n                    question: question.question,\r\n                    options: question.options,\r\n                    correctAnswer: question.correctAnswer,\r\n                    explanation: question.explanation,\r\n                    module: jsonData.module,\r\n                    month: jsonData.month,\r\n                    year: jsonData.year\r\n                };\r\n                \r\n                const questionId = await createQuestion(questionData);\r\n                importedIds.push(questionId);\r\n            } catch (err) {\r\n                errors.push({ index: i, error: err.message });\r\n                console.error(`‚ùå Erreur question ${i + 1}:`, err.message);\r\n            }\r\n        }\r\n        \r\n        await createImportLog({\r\n            importedBy: user.uid,\r\n            module: jsonData.module,\r\n            month: jsonData.month,\r\n            year: jsonData.year,\r\n            totalQuestions: jsonData.questions.length,\r\n            successCount: importedIds.length,\r\n            errorCount: errors.length,\r\n            status: errors.length === 0 ? 'success' : 'partial'\r\n        });\r\n        \r\n        console.log(`‚úÖ Import termin√©: ${importedIds.length}/${jsonData.questions.length} questions import√©es`);\r\n\r\n        invalidateCache('questions');\r\n        invalidateCache('questions-stats');\r\n        \r\n        return {\r\n            success: importedIds.length,\r\n            total: jsonData.questions.length,\r\n            errors: errors,\r\n            ids: importedIds\r\n        };\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur import JSON:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * ADMIN: R√©cup√©rer les statistiques des questions\r\n */\r\nexport async function getQuestionsStats() {\r\n    const cacheKey = 'questions-stats';\r\n    const cached = getCachedValue(cacheKey);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n\r\n    try {\r\n        const questions = await getQuestions();\r\n        \r\n        const stats = {\r\n            total: questions.length,\r\n            byModule: {},\r\n            byMonth: {},\r\n            byYear: {}\r\n        };\r\n        \r\n        questions.forEach(q => {\r\n            stats.byModule[q.module] = (stats.byModule[q.module] || 0) + 1;\r\n            stats.byMonth[q.month] = (stats.byMonth[q.month] || 0) + 1;\r\n            stats.byYear[q.year] = (stats.byYear[q.year] || 0) + 1;\r\n        });\r\n        \r\n        setCachedValue(cacheKey, stats, 'stats');\r\n        return stats;\r\n    } catch (error) {\r\n        console.error('‚ùå Erreur statistiques questions:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n","/**\r\n * Gestionnaire d'√âtat Centralis√©\r\n * \r\n * ‚úÖ CORRECTION SECTION 5 : Centralisation des variables globales\r\n * \r\n * Remplace toutes les variables globales √©parpill√©es dans :\r\n * - js/quiz.js\r\n * - js/dashboard.js\r\n * - js/admin-dashboard.js\r\n * - etc.\r\n * \r\n * Avantages :\r\n * - √âtat centralis√© et tra√ßable\r\n * - Pas de conflits de noms\r\n * - Tests facilit√©s\r\n * - Reset automatique possible\r\n */\r\n\r\nclass StateManager {\r\n    constructor() {\r\n        // √âtat initial\r\n        this.state = {\r\n            // Quiz state\r\n            currentQuiz: null,\r\n            currentQuestionIndex: 0,\r\n            userAnswers: [],\r\n            startTime: null,\r\n            timerInterval: null,\r\n            questionStartTime: null,\r\n            pausedDuration: 0,\r\n            isPaused: false,\r\n            currentModule: null,\r\n            currentMonth: null,\r\n            currentYear: null,\r\n            currentStreak: 0,\r\n            \r\n            // Dashboard state\r\n            monthsData: [],\r\n            currentMonthIndex: null,\r\n            annualProgress: {},\r\n            userProfile: null,\r\n            \r\n            // Admin state\r\n            globalStats: null,\r\n            topUsers: [],\r\n            recentActivity: [],\r\n            allUsers: [],\r\n            questionsStats: null,\r\n            usersStats: null,\r\n            \r\n            // Auth state\r\n            currentUser: null,\r\n            isDemoMode: false,\r\n            clientId: null,\r\n            \r\n            // UI state\r\n            isLoading: false,\r\n            error: null,\r\n            notifications: []\r\n        };\r\n        \r\n        // Listeners pour les changements d'√©tat\r\n        this.listeners = new Map();\r\n        \r\n        // Historique pour le debug (optionnel)\r\n        this.history = [];\r\n        this.maxHistorySize = 50;\r\n    }\r\n    \r\n    /**\r\n     * Obtenir une valeur de l'√©tat\r\n     * @param {string} key - Cl√© de l'√©tat\r\n     * @returns {*} Valeur de l'√©tat\r\n     */\r\n    get(key) {\r\n        if (key.includes('.')) {\r\n            // Support pour les cl√©s imbriqu√©es (ex: 'quiz.currentQuestionIndex')\r\n            const keys = key.split('.');\r\n            let value = this.state;\r\n            for (const k of keys) {\r\n                if (value == null) return undefined;\r\n                value = value[k];\r\n            }\r\n            return value;\r\n        }\r\n        return this.state[key];\r\n    }\r\n    \r\n    /**\r\n     * D√©finir une valeur dans l'√©tat\r\n     * @param {string} key - Cl√© de l'√©tat\r\n     * @param {*} value - Nouvelle valeur\r\n     * @param {boolean} silent - Si true, ne d√©clenche pas les listeners\r\n     */\r\n    set(key, value, silent = false) {\r\n        const oldValue = this.get(key);\r\n        \r\n        if (key.includes('.')) {\r\n            // Support pour les cl√©s imbriqu√©es\r\n            const keys = key.split('.');\r\n            const lastKey = keys.pop();\r\n            let target = this.state;\r\n            for (const k of keys) {\r\n                if (!target[k] || typeof target[k] !== 'object') {\r\n                    target[k] = {};\r\n                }\r\n                target = target[k];\r\n            }\r\n            target[lastKey] = value;\r\n        } else {\r\n            this.state[key] = value;\r\n        }\r\n        \r\n        // Ajouter √† l'historique\r\n        this.addToHistory(key, value, oldValue);\r\n        \r\n        // Notifier les listeners\r\n        if (!silent) {\r\n            this.notify(key, value, oldValue);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Mettre √† jour plusieurs valeurs en une fois\r\n     * @param {Object} updates - Objet avec les cl√©s/valeurs √† mettre √† jour\r\n     */\r\n    update(updates) {\r\n        Object.keys(updates).forEach(key => {\r\n            this.set(key, updates[key], true);\r\n        });\r\n        // Notifier une seule fois pour toutes les mises √† jour\r\n        Object.keys(updates).forEach(key => {\r\n            this.notify(key, updates[key], this.get(key));\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * S'abonner aux changements d'une cl√©\r\n     * @param {string} key - Cl√© √† √©couter\r\n     * @param {Function} callback - Fonction appel√©e lors du changement\r\n     * @returns {Function} Fonction de d√©sabonnement\r\n     */\r\n    subscribe(key, callback) {\r\n        if (!this.listeners.has(key)) {\r\n            this.listeners.set(key, []);\r\n        }\r\n        this.listeners.get(key).push(callback);\r\n        \r\n        // Retourner fonction de d√©sabonnement\r\n        return () => {\r\n            const callbacks = this.listeners.get(key);\r\n            if (callbacks) {\r\n                const index = callbacks.indexOf(callback);\r\n                if (index > -1) {\r\n                    callbacks.splice(index, 1);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Notifier les listeners d'un changement\r\n     * @param {string} key - Cl√© modifi√©e\r\n     * @param {*} newValue - Nouvelle valeur\r\n     * @param {*} oldValue - Ancienne valeur\r\n     */\r\n    notify(key, newValue, oldValue) {\r\n        const callbacks = this.listeners.get(key) || [];\r\n        callbacks.forEach(callback => {\r\n            try {\r\n                callback(newValue, oldValue, key);\r\n            } catch (error) {\r\n                console.error(`‚ùå Erreur dans listener pour ${key}:`, error);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * R√©initialiser l'√©tat du quiz\r\n     */\r\n    resetQuiz() {\r\n        this.update({\r\n            currentQuiz: null,\r\n            currentQuestionIndex: 0,\r\n            userAnswers: [],\r\n            startTime: null,\r\n            timerInterval: null,\r\n            questionStartTime: null,\r\n            pausedDuration: 0,\r\n            isPaused: false,\r\n            currentModule: null,\r\n            currentMonth: null,\r\n            currentYear: null\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * R√©initialiser l'√©tat du dashboard\r\n     */\r\n    resetDashboard() {\r\n        this.update({\r\n            monthsData: [],\r\n            currentMonthIndex: null,\r\n            annualProgress: {}\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * R√©initialiser l'√©tat admin\r\n     */\r\n    resetAdmin() {\r\n        this.update({\r\n            globalStats: null,\r\n            topUsers: [],\r\n            recentActivity: [],\r\n            allUsers: [],\r\n            questionsStats: null,\r\n            usersStats: null\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * R√©initialiser tout l'√©tat (sauf auth)\r\n     */\r\n    reset() {\r\n        this.resetQuiz();\r\n        this.resetDashboard();\r\n        this.resetAdmin();\r\n        this.set('error', null);\r\n        this.set('isLoading', false);\r\n    }\r\n    \r\n    /**\r\n     * Ajouter une entr√©e √† l'historique\r\n     * @param {string} key - Cl√© modifi√©e\r\n     * @param {*} newValue - Nouvelle valeur\r\n     * @param {*} oldValue - Ancienne valeur\r\n     */\r\n    addToHistory(key, newValue, oldValue) {\r\n        this.history.push({\r\n            key,\r\n            newValue,\r\n            oldValue,\r\n            timestamp: Date.now()\r\n        });\r\n        \r\n        // Limiter la taille de l'historique\r\n        if (this.history.length > this.maxHistorySize) {\r\n            this.history.shift();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Obtenir l'historique des changements\r\n     * @param {string} key - Filtrer par cl√© (optionnel)\r\n     * @returns {Array} Historique\r\n     */\r\n    getHistory(key = null) {\r\n        if (key) {\r\n            return this.history.filter(entry => entry.key === key);\r\n        }\r\n        return [...this.history];\r\n    }\r\n    \r\n    /**\r\n     * Obtenir un snapshot de l'√©tat complet\r\n     * @returns {Object} Copie de l'√©tat\r\n     */\r\n    getSnapshot() {\r\n        return JSON.parse(JSON.stringify(this.state));\r\n    }\r\n    \r\n    /**\r\n     * Restaurer un snapshot de l'√©tat\r\n     * @param {Object} snapshot - Snapshot √† restaurer\r\n     */\r\n    restoreSnapshot(snapshot) {\r\n        this.state = JSON.parse(JSON.stringify(snapshot));\r\n        // Notifier tous les listeners\r\n        Object.keys(snapshot).forEach(key => {\r\n            this.notify(key, snapshot[key], this.get(key));\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * V√©rifier si une cl√© existe dans l'√©tat\r\n     * @param {string} key - Cl√© √† v√©rifier\r\n     * @returns {boolean} True si la cl√© existe\r\n     */\r\n    has(key) {\r\n        if (key.includes('.')) {\r\n            const keys = key.split('.');\r\n            let value = this.state;\r\n            for (const k of keys) {\r\n                if (value == null || !(k in value)) return false;\r\n                value = value[k];\r\n            }\r\n            return true;\r\n        }\r\n        return key in this.state;\r\n    }\r\n    \r\n    /**\r\n     * Supprimer une cl√© de l'√©tat\r\n     * @param {string} key - Cl√© √† supprimer\r\n     */\r\n    delete(key) {\r\n        const oldValue = this.get(key);\r\n        \r\n        if (key.includes('.')) {\r\n            const keys = key.split('.');\r\n            const lastKey = keys.pop();\r\n            let target = this.state;\r\n            for (const k of keys) {\r\n                if (!target[k] || typeof target[k] !== 'object') {\r\n                    return; // Cl√© non trouv√©e\r\n                }\r\n                target = target[k];\r\n            }\r\n            delete target[lastKey];\r\n        } else {\r\n            delete this.state[key];\r\n        }\r\n        \r\n        this.addToHistory(key, undefined, oldValue);\r\n        this.notify(key, undefined, oldValue);\r\n    }\r\n}\r\n\r\n// Export singleton\r\nexport const stateManager = new StateManager();\r\n\r\n// Export de la classe pour les tests\r\nexport { StateManager };\r\n\r\n// Helpers pour faciliter l'utilisation\r\nexport const state = {\r\n    get: (key) => stateManager.get(key),\r\n    set: (key, value) => stateManager.set(key, value),\r\n    update: (updates) => stateManager.update(updates),\r\n    subscribe: (key, callback) => stateManager.subscribe(key, callback),\r\n    reset: () => stateManager.reset(),\r\n    resetQuiz: () => stateManager.resetQuiz(),\r\n    resetDashboard: () => stateManager.resetDashboard(),\r\n    resetAdmin: () => stateManager.resetAdmin()\r\n};\r\n\r\n"],"file":"services-DH3azNjH.js"}