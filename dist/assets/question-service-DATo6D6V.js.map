{"version":3,"file":"question-service-DATo6D6V.js","sources":["../../js/services/question-service.js"],"sourcesContent":["/**\n * Service de Gestion des Questions\n * \n * ‚úÖ CORRECTION SECTION 5 : Refactorisation - Extraction des fonctions questions\n */\n\nimport { db, auth } from '../firebase-config.js';\nimport { \n    collection, \n    doc, \n    getDoc, \n    getDocs, \n    addDoc,\n    updateDoc,\n    deleteDoc,\n    query,\n    where,\n    orderBy,\n    limit,\n    startAfter,\n    Timestamp\n} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';\nimport { safeFirestoreRead, safeFirestoreWrite } from '../rate-limiter.js';\nimport { buildCacheKey, getCachedValue, setCachedValue, invalidateCache } from './cache-service.js';\nimport { createAuditLog, createImportLog } from './audit-service.js';\n\nconst COLLECTIONS = {\n    questions: 'questions'\n};\n\n/**\n * ADMIN: R√©cup√©rer toutes les questions avec filtres optionnels (sans pagination - pour compatibilit√©)\n */\nexport async function getQuestions(filters = {}) {\n    const cacheKey = buildCacheKey(['questions', JSON.stringify(filters || {})]);\n    const cached = getCachedValue(cacheKey);\n    if (cached) {\n        return cached;\n    }\n\n    try {\n        let q = collection(db, COLLECTIONS.questions);\n        const constraints = [];\n        \n        if (filters.module) {\n            constraints.push(where('module', '==', filters.module));\n        }\n        if (filters.month) {\n            constraints.push(where('month', '==', filters.month));\n        }\n        if (filters.year) {\n            constraints.push(where('year', '==', filters.year));\n        }\n        \n        constraints.push(orderBy('createdAt', 'desc'));\n        \n        if (constraints.length > 0) {\n            q = query(q, ...constraints);\n        }\n        \n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\n        const questions = [];\n        \n        querySnapshot.forEach((doc) => {\n            questions.push({ id: doc.id, ...doc.data() });\n        });\n        \n        console.log(`üìö ${questions.length} questions charg√©es`);\n        setCachedValue(cacheKey, questions, 'questions');\n        return questions;\n    } catch (error) {\n        console.error('‚ùå Erreur r√©cup√©ration questions:', error);\n        throw error;\n    }\n}\n\n/**\n * ‚úÖ CORRECTION SECTION 7 : Pagination - R√©cup√©rer les questions avec pagination\n * @param {Object} filters - Filtres optionnels\n * @param {number} pageSize - Nombre d'√©l√©ments par page (d√©faut: 20)\n * @param {QueryDocumentSnapshot|null} lastDoc - Document de d√©part pour la pagination\n * @returns {Promise<{questions: Array, lastDoc: QueryDocumentSnapshot|null, hasMore: boolean}>}\n */\nexport async function getQuestionsPaginated(filters = {}, pageSize = 20, lastDoc = null) {\n    try {\n        let q = collection(db, COLLECTIONS.questions);\n        const constraints = [];\n        \n        if (filters.module) {\n            constraints.push(where('module', '==', filters.module));\n        }\n        if (filters.month) {\n            constraints.push(where('month', '==', filters.month));\n        }\n        if (filters.year) {\n            constraints.push(where('year', '==', filters.year));\n        }\n        \n        constraints.push(orderBy('createdAt', 'desc'));\n        constraints.push(limit(pageSize + 1)); // +1 pour d√©tecter s'il y a plus de r√©sultats\n        \n        if (constraints.length > 0) {\n            q = query(q, ...constraints);\n        }\n        \n        // Si on a un document de d√©part, commencer apr√®s\n        if (lastDoc) {\n            q = query(q, startAfter(lastDoc));\n        }\n        \n        const querySnapshot = await safeFirestoreRead(() => getDocs(q));\n        const questions = [];\n        let newLastDoc = null;\n        let hasMore = false;\n        \n        querySnapshot.forEach((doc, index) => {\n            if (index < pageSize) {\n                questions.push({ id: doc.id, ...doc.data() });\n            } else {\n                hasMore = true;\n            }\n        });\n        \n        if (querySnapshot.docs.length > 0 && questions.length === pageSize) {\n            newLastDoc = querySnapshot.docs[pageSize - 1];\n        }\n        \n        console.log(`üìö ${questions.length} questions charg√©es (pagination)`);\n        return {\n            questions,\n            lastDoc: newLastDoc,\n            hasMore\n        };\n    } catch (error) {\n        console.error('‚ùå Erreur r√©cup√©ration questions pagin√©es:', error);\n        throw error;\n    }\n}\n\n/**\n * ADMIN: Cr√©er une nouvelle question\n */\nexport async function createQuestion(questionData) {\n    try {\n        const user = auth.currentUser;\n        if (!user) throw new Error('Utilisateur non connect√©');\n        \n        if (!questionData.question || questionData.question.length < 10) {\n            throw new Error('La question doit contenir au moins 10 caract√®res');\n        }\n        if (!questionData.options || questionData.options.length !== 4) {\n            throw new Error('La question doit avoir exactement 4 options');\n        }\n        if (questionData.correctAnswer === undefined || questionData.correctAnswer < 0 || questionData.correctAnswer > 3) {\n            throw new Error('La r√©ponse correcte doit √™tre entre 0 et 3');\n        }\n        if (!questionData.explanation || questionData.explanation.length < 20) {\n            throw new Error('L\\'explication doit contenir au moins 20 caract√®res');\n        }\n        if (!['auto', 'loisir', 'vr', 'tracteur'].includes(questionData.module)) {\n            throw new Error('Module invalide');\n        }\n        if (!questionData.month || questionData.month < 1 || questionData.month > 12) {\n            throw new Error('Mois invalide');\n        }\n        \n        const newQuestion = {\n            question: questionData.question.trim(),\n            options: questionData.options.map(opt => opt.trim()),\n            correctAnswer: parseInt(questionData.correctAnswer),\n            explanation: questionData.explanation.trim(),\n            module: questionData.module,\n            month: parseInt(questionData.month),\n            year: questionData.year || new Date().getFullYear(),\n            createdAt: Timestamp.now(),\n            createdBy: user.uid,\n            updatedAt: Timestamp.now()\n        };\n        \n        const questionRef = await safeFirestoreWrite(() => \n            addDoc(collection(db, COLLECTIONS.questions), newQuestion)\n        );\n        console.log('‚úÖ Question cr√©√©e:', questionRef.id);\n        \n        await createAuditLog({\n            action: 'CREATE_QUESTION',\n            questionId: questionRef.id,\n            adminId: user.uid,\n            adminEmail: user.email\n        });\n\n        invalidateCache('questions');\n        invalidateCache('questions-stats');\n        \n        return questionRef.id;\n    } catch (error) {\n        console.error('‚ùå Erreur cr√©ation question:', error);\n        throw error;\n    }\n}\n\n/**\n * ADMIN: Mettre √† jour une question existante\n */\nexport async function updateQuestion(questionId, questionData) {\n    try {\n        const user = auth.currentUser;\n        if (!user) throw new Error('Utilisateur non connect√©');\n        \n        const questionRef = doc(db, COLLECTIONS.questions, questionId);\n        \n        const updatedData = {\n            ...questionData,\n            updatedAt: Timestamp.now()\n        };\n        \n        delete updatedData.createdAt;\n        delete updatedData.createdBy;\n        \n        await safeFirestoreWrite(() => updateDoc(questionRef, updatedData));\n        console.log('‚úÖ Question mise √† jour:', questionId);\n        \n        await createAuditLog({\n            action: 'UPDATE_QUESTION',\n            questionId: questionId,\n            adminId: user.uid,\n            adminEmail: user.email,\n            changes: questionData\n        });\n\n        invalidateCache('questions');\n        invalidateCache('questions-stats');\n        \n        return true;\n    } catch (error) {\n        console.error('‚ùå Erreur mise √† jour question:', error);\n        throw error;\n    }\n}\n\n/**\n * ADMIN: Supprimer une question\n */\nexport async function deleteQuestion(questionId) {\n    try {\n        const user = auth.currentUser;\n        if (!user) throw new Error('Utilisateur non connect√©');\n        \n        const questionRef = doc(db, COLLECTIONS.questions, questionId);\n        \n        const questionDoc = await safeFirestoreRead(() => getDoc(questionRef));\n        const questionData = questionDoc.data();\n        \n        await safeFirestoreWrite(() => deleteDoc(questionRef));\n        console.log('üóëÔ∏è Question supprim√©e:', questionId);\n        \n        await createAuditLog({\n            action: 'DELETE_QUESTION',\n            questionId: questionId,\n            adminId: user.uid,\n            adminEmail: user.email,\n            deletedData: questionData\n        });\n\n        invalidateCache('questions');\n        invalidateCache('questions-stats');\n        \n        return true;\n    } catch (error) {\n        console.error('‚ùå Erreur suppression question:', error);\n        throw error;\n    }\n}\n\n/**\n * ADMIN: Importer des questions depuis JSON\n */\nexport async function importQuestionsFromJSON(jsonData) {\n    try {\n        const user = auth.currentUser;\n        if (!user) throw new Error('Utilisateur non connect√©');\n        \n        if (!jsonData.module || !jsonData.month || !jsonData.year || !jsonData.questions) {\n            throw new Error('Format JSON invalide - champs obligatoires manquants');\n        }\n        \n        if (!Array.isArray(jsonData.questions) || jsonData.questions.length === 0) {\n            throw new Error('Le fichier JSON doit contenir au moins une question');\n        }\n        \n        const importedIds = [];\n        const errors = [];\n        \n        for (let i = 0; i < jsonData.questions.length; i++) {\n            const question = jsonData.questions[i];\n            \n            try {\n                const questionData = {\n                    question: question.question,\n                    options: question.options,\n                    correctAnswer: question.correctAnswer,\n                    explanation: question.explanation,\n                    module: jsonData.module,\n                    month: jsonData.month,\n                    year: jsonData.year\n                };\n                \n                const questionId = await createQuestion(questionData);\n                importedIds.push(questionId);\n            } catch (err) {\n                errors.push({ index: i, error: err.message });\n                console.error(`‚ùå Erreur question ${i + 1}:`, err.message);\n            }\n        }\n        \n        await createImportLog({\n            importedBy: user.uid,\n            module: jsonData.module,\n            month: jsonData.month,\n            year: jsonData.year,\n            totalQuestions: jsonData.questions.length,\n            successCount: importedIds.length,\n            errorCount: errors.length,\n            status: errors.length === 0 ? 'success' : 'partial'\n        });\n        \n        console.log(`‚úÖ Import termin√©: ${importedIds.length}/${jsonData.questions.length} questions import√©es`);\n\n        invalidateCache('questions');\n        invalidateCache('questions-stats');\n        \n        return {\n            success: importedIds.length,\n            total: jsonData.questions.length,\n            errors: errors,\n            ids: importedIds\n        };\n    } catch (error) {\n        console.error('‚ùå Erreur import JSON:', error);\n        throw error;\n    }\n}\n\n/**\n * ADMIN: R√©cup√©rer les statistiques des questions\n */\nexport async function getQuestionsStats() {\n    const cacheKey = 'questions-stats';\n    const cached = getCachedValue(cacheKey);\n    if (cached) {\n        return cached;\n    }\n\n    try {\n        const questions = await getQuestions();\n        \n        const stats = {\n            total: questions.length,\n            byModule: {},\n            byMonth: {},\n            byYear: {}\n        };\n        \n        questions.forEach(q => {\n            stats.byModule[q.module] = (stats.byModule[q.module] || 0) + 1;\n            stats.byMonth[q.month] = (stats.byMonth[q.month] || 0) + 1;\n            stats.byYear[q.year] = (stats.byYear[q.year] || 0) + 1;\n        });\n        \n        setCachedValue(cacheKey, stats, 'stats');\n        return stats;\n    } catch (error) {\n        console.error('‚ùå Erreur statistiques questions:', error);\n        throw error;\n    }\n}\n\n"],"names":["COLLECTIONS","getQuestions","filters","cacheKey","buildCacheKey","cached","getCachedValue","q","collection","db","constraints","where","orderBy","query","querySnapshot","safeFirestoreRead","getDocs","questions","doc","setCachedValue","error","createQuestion","questionData","user","auth","newQuestion","opt","Timestamp","questionRef","safeFirestoreWrite","addDoc","createAuditLog","invalidateCache","deleteQuestion","questionId","getDoc","deleteDoc","importQuestionsFromJSON","jsonData","importedIds","errors","i","question","err","createImportLog","getQuestionsStats","stats"],"mappings":"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"}